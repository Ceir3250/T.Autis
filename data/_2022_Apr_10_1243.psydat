ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
VC:\u005cUsers\u005cjeiso\u005cDesktop\u005cOpenSourceIRAP-master\u005cOpen Source IRAP.psyexp
p7
sS'dataFileName'
p8
VC:\u005cUsers\u005cjeiso\u005cDocuments\u005cOpenSourceIRAP-master\u005cdata\u005c_2022_Apr_10_1243
p9
sS'runtimeInfo'
p10
NsS'name'
p11
VIRAP
p12
sS'dataNames'
p13
(lp14
sS'autoLog'
p15
I01
sS'extraInfo'
p16
(dp17
Vparticipant
p18
V
sVUseMonkey
p19
Vn
sVgender
p20
V
sVage
p21
V
sS'frameRate'
p22
cnumpy.core.multiarray
scalar
p23
(cnumpy
dtype
p24
(S'f8'
I0
I1
tRp25
(I3
S'<'
NNNI-1
I-1
I0
tbS'0\x8a\xfe\xb0Z\xd0M@'
tRp26
sS'expName'
p27
g12
sS'date'
p28
V2022_Apr_10_1243
p29
sVStartingBlock
p30
Va
ssS'loopsUnfinished'
p31
(lp32
g1
(cpsychopy.data
TrialHandler
p33
g3
NtRp34
(dp35
S'origin'
p36
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.85.2), April 10, 2022, at 12:39\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'IRAP'  # from the Builder filename that created this script\u000aexpInfo = {u'gender': u'', u'age': u'', u'participant': u'', u'StartingBlock': u'a', u'UseMonkey': u'n'}\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.path.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1504, 1003), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor=u'testMonitor', color=u'black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='norm')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000a# Dependencies&#10;&#10;from psychopy.hardware.emulator import ResponseEmulator  #for response emulator&#10;import itertools  # for flattening lists of lists into lists&#10;import random  # for shuffling lists&#10;&#10;# Functions&#10;&#10;# Convert string to boolean.&#10;# Take any likely input from the task.xlsx file and convert to a boolean. This helps to idiot-proof the excel files.&#10;def string_to_booleanl(v):&#10;  return v.lower() in ("yes", "true", "TRUE", "True", "t", "T", 1)&#10;&#10;# Trial generation function&#10;def generate_trials(trial_type_column, multiplier, shuffle_list):&#10;    """Generate a shuffled list of stimuli exemplars from a column in an excel stimuli file""" &#10;    a = dict()  # declare a dict to be populated&#10;    for i in range(len(exemplars)):&#10;        a[i] = [exemplars[i][trial_type_column]] * multiplier  # populate the dict from vertical reads of the conditions&#10;    a = a.values()  # extract only values (and not keys) from the list of dicts&#10;    a = list(itertools.chain(*a))  # flatten the list of dicts into a list&#10;    if shuffle_list == True:&#10;        random.shuffle(a)  # shuffle this list, so that it can be drawn from by the trials&#10;    return a&#10;&#10;&#10;# Determine variables based on dialogue box&#10;&#10;# auto response monkey&#10;if str(expInfo['UseMonkey']) == 'y' or str(expInfo['UseMonkey']) == 'Y' or str(expInfo['UseMonkey']) == 'yes' or str(expInfo['UseMonkey']) == 't' or str(expInfo['UseMonkey']) == 'true' or str(expInfo['UseMonkey']) == 'True' or str(expInfo['UseMonkey']) == 'TRUE':&#10;    Monkey = True&#10;else:&#10;    Monkey = False&#10;&#10;# starting block&#10;if str(expInfo['StartingBlock']) == 'a' or str(expInfo['StartingBlock']) == 'A':&#10;    starting_block = 'a'&#10;    Afirst_nReps = 1&#10;    Asecond_nReps = 0&#10;elif str(expInfo['StartingBlock']) == 'b' or str(expInfo['StartingBlock']) == 'B':&#10;    starting_block = 'b'&#10;    Afirst_nReps = 0&#10;    Asecond_nReps = 1&#10;\u000aintro_box = visual.TextStim(win=win, ori=0, name='intro_box',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "practice_postblock_A"\u000apractice_postblock_AClock = core.Clock()\u000a\u000apractice_aim_box_A = visual.TextStim(win=win, ori=0, name='practice_aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_accuracy_box_A = visual.TextStim(win=win, ori=0, name='practice_accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_latency_box_A = visual.TextStim(win=win, ori=0, name='practice_latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_prac_A = visual.TextStim(win=win, ori=0, name='press_box_prac_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_B"\u000apreblock_BClock = core.Clock()\u000a\u000arule_box_B = visual.TextStim(win=win, ori=0, name='rule_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='cyan', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_B"\u000atrial_BClock = core.Clock()\u000a#msg variable just needs some value at start&#10;accuracyFeedback=''\u000aimage_stimulus1_box_B = visual.ImageStim(win=win, name='image_stimulus1_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_B = visual.ImageStim(win=win, name='image_stimulus2_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_B = visual.TextStim(win=win, ori=0, name='stimulus1_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_B = visual.TextStim(win=win, ori=0, name='stimulus2_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_B = visual.TextStim(win=win, ori=0, name='left_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_B = visual.TextStim(win=win, ori=0, name='right_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_B = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "practice_postblock_B"\u000apractice_postblock_BClock = core.Clock()\u000a\u000apractice_aim_box_B = visual.TextStim(win=win, ori=0, name='practice_aim_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_accuracy_box_B = visual.TextStim(win=win, ori=0, name='practice_accuracy_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_latency_box_B = visual.TextStim(win=win, ori=0, name='practice_latency_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_prac_B = visual.TextStim(win=win, ori=0, name='press_box_prac_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "practice_postblock_A"\u000apractice_postblock_AClock = core.Clock()\u000a\u000apractice_aim_box_A = visual.TextStim(win=win, ori=0, name='practice_aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_accuracy_box_A = visual.TextStim(win=win, ori=0, name='practice_accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_latency_box_A = visual.TextStim(win=win, ori=0, name='practice_latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_prac_A = visual.TextStim(win=win, ori=0, name='press_box_prac_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "end_practice_blocks"\u000aend_practice_blocksClock = core.Clock()\u000a# by default, don't do test blocks. Change elsewhere if mastery criteria are met.&#10;complete_test_blocks = 0\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "postblock_A"\u000apostblock_AClock = core.Clock()\u000a\u000aaim_box_A = visual.TextStim(win=win, ori=0, name='aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aaccuracy_box_A = visual.TextStim(win=win, ori=0, name='accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000alatency_box_A = visual.TextStim(win=win, ori=0, name='latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_A = visual.TextStim(win=win, ori=0, name='press_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_B"\u000apreblock_BClock = core.Clock()\u000a\u000arule_box_B = visual.TextStim(win=win, ori=0, name='rule_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='cyan', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_B"\u000atrial_BClock = core.Clock()\u000a#msg variable just needs some value at start&#10;accuracyFeedback=''\u000aimage_stimulus1_box_B = visual.ImageStim(win=win, name='image_stimulus1_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_B = visual.ImageStim(win=win, name='image_stimulus2_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_B = visual.TextStim(win=win, ori=0, name='stimulus1_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_B = visual.TextStim(win=win, ori=0, name='stimulus2_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_B = visual.TextStim(win=win, ori=0, name='left_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_B = visual.TextStim(win=win, ori=0, name='right_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_B = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "postblock_B"\u000apostblock_BClock = core.Clock()\u000a\u000aaim_box_B = visual.TextStim(win=win, ori=0, name='aim_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aaccuracy_box_B = visual.TextStim(win=win, ori=0, name='accuracy_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000alatency_box_B = visual.TextStim(win=win, ori=0, name='latency_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_B = visual.TextStim(win=win, ori=0, name='press_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "postblock_A"\u000apostblock_AClock = core.Clock()\u000a\u000aaim_box_A = visual.TextStim(win=win, ori=0, name='aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aaccuracy_box_A = visual.TextStim(win=win, ori=0, name='accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000alatency_box_A = visual.TextStim(win=win, ori=0, name='latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_A = visual.TextStim(win=win, ori=0, name='press_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "end"\u000aendClock = core.Clock()\u000aend_box = visual.TextStim(win=win, ori=0, name='end_box',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a    trialList=data.importConditions('task.xlsx'),\u000a    seed=None, name='task')\u000athisExp.addLoop(task)  # add the loop to the experiment\u000athisTask = task.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask.rgb)\u000aif thisTask != None:\u000a    for paramName in thisTask.keys():\u000a        exec(paramName + '= thisTask.' + paramName)\u000a\u000afor thisTask in task:\u000a    currentLoop = task\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask.rgb)\u000a    if thisTask != None:\u000a        for paramName in thisTask.keys():\u000a            exec(paramName + '= thisTask.' + paramName)\u000a    \u000a    #------Prepare to start Routine "instructions"-------\u000a    t = 0\u000a    instructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # ResponseEmulator&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Create sufficiently long lists of stimuli&#10;"""&#10;This allows us to keep the stimuli in an excel file across multiple lines, and to present them based on the categories &#10;set by the 'layout.xlsx' file. This allows for shuffled (counterbalanced pseudorandom) presentation of the stimuli examplars &#10;as well as the categories. &#10;&#10;The method to do this below is to first declare a dictionary to be populated from the exemplars conditions, but not in the usual way. &#10;Usually, psychopy would read across columns. If the stimuli were entered as a list within the excel file (e.g., ['male', 'female']) &#10;rather on seperate rows as they are now all we would have to do is multiply the length of the list to get enough exemplars. However, &#10;I wanted the stimuli file to be as use friendly as possible, so instead the below code allows you to enter the exemplars on seperate&#10;rows, and then populates the dict vertically from the rows. &#10;"""&#10;# Import stimuli exemplars&#10;exemplars = data.importConditions(stimulus_file)  # Import stimuli exemplars. stimulus_file is defined in task.xlsx&#10;&#10;# Determine nReps of trials loop based on number of exemplars&#10;reptitions = len(exemplars)&#10;&#10;&#10;# Generate a first, unshuffled list of the stimuli exemplars for saving to output file&#10;&#10;# 1. generate: no shuffling, multiplier = 1.&#10;labelA_stimuli_for_output = generate_trials('labelA_stimuli', 1, False)  # function and variable determined at begin exp.&#10;labelB_stimuli_for_output = generate_trials('labelB_stimuli', 1, False)&#10;targetA_stimuli_for_output = generate_trials('targetA_stimuli', 1, False)&#10;targetB_stimuli_for_output = generate_trials('targetB_stimuli', 1, False)&#10;labelA_image_stimuli_for_output = generate_trials('labelA_image_stimuli', 1, False)&#10;labelB_image_stimuli_for_output = generate_trials('labelB_image_stimuli', 1, False)&#10;targetA_image_stimuli_for_output = generate_trials('targetA_image_stimuli', 1, False)&#10;targetB_image_stimuli_for_output = generate_trials('targetB_image_stimuli', 1, False)&#10;&#10;# 2. save these lists to the trial handler to be written to csv&#10;thisExp.addData('labelA_stimuli_for_output', labelA_stimuli_for_output)&#10;thisExp.addData('labelB_stimuli_for_output', labelB_stimuli_for_output)&#10;thisExp.addData('targetA_stimuli_for_output', targetA_stimuli_for_output)&#10;thisExp.addData('targetB_stimuli_for_output', targetB_stimuli_for_output)&#10;thisExp.addData('labelA_image_stimuli_for_output', labelA_image_stimuli_for_output)&#10;thisExp.addData('labelB_image_stimuli_for_output', labelB_image_stimuli_for_output)&#10;thisExp.addData('targetA_image_stimuli_for_output', targetA_image_stimuli_for_output)&#10;thisExp.addData('targetB_image_stimuli_for_output', targetB_image_stimuli_for_output)\u000a    intro_box.setText(intro_message)\u000a    intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    intro_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    instructionsComponents = []\u000a    instructionsComponents.append(intro_box)\u000a    instructionsComponents.append(intro_resp)\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = instructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *intro_box* updates\u000a        if t >= 0.4 and intro_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            intro_box.tStart = t  # underestimates by a little under one frame\u000a            intro_box.frameNStart = frameN  # exact frame index\u000a            intro_box.setAutoDraw(True)\u000a        \u000a        # *intro_resp* updates\u000a        if t >= 1 and intro_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            intro_resp.tStart = t  # underestimates by a little under one frame\u000a            intro_resp.frameNStart = frameN  # exact frame index\u000a            intro_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if intro_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['e', 'i'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in instructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "instructions"-------\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "instructions" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    practice_blocks = data.TrialHandler(nReps=max_pairs_practice_blocks, method='sequential', \u000a        extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a        trialList=[None],\u000a        seed=None, name='practice_blocks')\u000a    thisExp.addLoop(practice_blocks)  # add the loop to the experiment\u000a    thisPractice_block = practice_blocks.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisPractice_block.rgb)\u000a    if thisPractice_block != None:\u000a        for paramName in thisPractice_block.keys():\u000a            exec(paramName + '= thisPractice_block.' + paramName)\u000a    \u000a    for thisPractice_block in practice_blocks:\u000a        currentLoop = practice_blocks\u000a        # abbreviate parameter names if possible (e.g. rgb = thisPractice_block.rgb)\u000a        if thisPractice_block != None:\u000a            for paramName in thisPractice_block.keys():\u000a                exec(paramName + '= thisPractice_block.' + paramName)\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        practice_Afirst = data.TrialHandler(nReps=Afirst_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='practice_Afirst')\u000a        thisExp.addLoop(practice_Afirst)  # add the loop to the experiment\u000a        thisPractice_Afirst = practice_Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisPractice_Afirst.rgb)\u000a        if thisPractice_Afirst != None:\u000a            for paramName in thisPractice_Afirst.keys():\u000a                exec(paramName + '= thisPractice_Afirst.' + paramName)\u000a        \u000a        for thisPractice_Afirst in practice_Afirst:\u000a            currentLoop = practice_Afirst\u000a            # abbreviate parameter names if possible (e.g. rgb = thisPractice_Afirst.rgb)\u000a            if thisPractice_Afirst != None:\u000a                for paramName in thisPractice_Afirst.keys():\u000a                    exec(paramName + '= thisPractice_Afirst.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            practice_trials_Afirst = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='practice_trials_Afirst')\u000a            thisExp.addLoop(practice_trials_Afirst)  # add the loop to the experiment\u000a            thisPractice_trials_Afirst = practice_trials_Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisPractice_trials_Afirst.rgb)\u000a            if thisPractice_trials_Afirst != None:\u000a                for paramName in thisPractice_trials_Afirst.keys():\u000a                    exec(paramName + '= thisPractice_trials_Afirst.' + paramName)\u000a            \u000a            for thisPractice_trials_Afirst in practice_trials_Afirst:\u000a                currentLoop = practice_trials_Afirst\u000a                # abbreviate parameter names if possible (e.g. rgb = thisPractice_trials_Afirst.rgb)\u000a                if thisPractice_trials_Afirst != None:\u000a                    for paramName in thisPractice_trials_Afirst.keys():\u000a                        exec(paramName + '= thisPractice_trials_Afirst.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Afirst (TrialHandler)\u000a                practice_trials_Afirst.addData('required_response_A.keys',required_response_A.keys)\u000a                practice_trials_Afirst.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    practice_trials_Afirst.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Afirst (TrialHandler)\u000a                practice_trials_Afirst.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                practice_trials_Afirst.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    practice_trials_Afirst.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'practice_trials_Afirst'\u000a            \u000a            \u000a            #------Prepare to start Routine "practice_postblock_A"-------\u000a            t = 0\u000a            practice_postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Afirst.data['required_response_A.corr'].count()) - float(practice_trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Asecond.data['required_response_A.corr'].count()) - float(practice_trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, prac_block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, prac_block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('prac_block_A_percentage_accuracy', prac_block_A_percentage_accuracy)&#10;##thisExp.addData('prac_block_A_median_latency', prac_block_A_median_latency)\u000a            practice_aim_box_A.setText(aim)\u000a            practice_accuracy_box_A.setText(msg_accuracy)\u000a            practice_latency_box_A.setText(msg_latency)\u000a            press_box_prac_A.setText(press_message)\u000a            practice_postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            practice_postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            practice_postblock_AComponents = []\u000a            practice_postblock_AComponents.append(practice_aim_box_A)\u000a            practice_postblock_AComponents.append(practice_accuracy_box_A)\u000a            practice_postblock_AComponents.append(practice_latency_box_A)\u000a            practice_postblock_AComponents.append(press_box_prac_A)\u000a            practice_postblock_AComponents.append(practice_postblock_response_A)\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "practice_postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = practice_postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *practice_aim_box_A* updates\u000a                if t >= 0.4 and practice_aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_aim_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_aim_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_accuracy_box_A* updates\u000a                if t >= 0.4 and practice_accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_latency_box_A* updates\u000a                if t >= 0.4 and practice_latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_latency_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_prac_A* updates\u000a                if t >= 0.4 and press_box_prac_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_prac_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_prac_A.frameNStart = frameN  # exact frame index\u000a                    press_box_prac_A.setAutoDraw(True)\u000a                \u000a                # *practice_postblock_response_A* updates\u000a                if t >= 1 and practice_postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    practice_postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if practice_postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in practice_postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "practice_postblock_A"-------\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "practice_postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Afirst_nReps repeats of 'practice_Afirst'\u000a        \u000a        \u000a        #------Prepare to start Routine "preblock_B"-------\u000a        t = 0\u000a        preblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)\u000a        rule_box_B.setText(rule_B)\u000a        preblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        preblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        preblock_BComponents = []\u000a        preblock_BComponents.append(rule_box_B)\u000a        preblock_BComponents.append(preblock_response_B)\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "preblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = preblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *rule_box_B* updates\u000a            if t >= 0.4 and rule_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rule_box_B.tStart = t  # underestimates by a little under one frame\u000a                rule_box_B.frameNStart = frameN  # exact frame index\u000a                rule_box_B.setAutoDraw(True)\u000a            \u000a            # *preblock_response_B* updates\u000a            if t >= 1 and preblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                preblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                preblock_response_B.frameNStart = frameN  # exact frame index\u000a                preblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if preblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in preblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "preblock_B"-------\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "preblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        practice_trials_B = data.TrialHandler(nReps=reptitions, method='random', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=data.importConditions('block_layout.xlsx'),\u000a            seed=None, name='practice_trials_B')\u000a        thisExp.addLoop(practice_trials_B)  # add the loop to the experiment\u000a        thisPractice_trials_B = practice_trials_B.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisPractice_trials_B.rgb)\u000a        if thisPractice_trials_B != None:\u000a            for paramName in thisPractice_trials_B.keys():\u000a                exec(paramName + '= thisPractice_trials_B.' + paramName)\u000a        \u000a        for thisPractice_trials_B in practice_trials_B:\u000a            currentLoop = practice_trials_B\u000a            # abbreviate parameter names if possible (e.g. rgb = thisPractice_trials_B.rgb)\u000a            if thisPractice_trials_B != None:\u000a                for paramName in thisPractice_trials_B.keys():\u000a                    exec(paramName + '= thisPractice_trials_B.' + paramName)\u000a            \u000a            #------Prepare to start Routine "trial_B"-------\u000a            t = 0\u000a            trial_BClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'\u000a            image_stimulus1_box_B.setPos(image_stimulus1_location)\u000a            image_stimulus1_box_B.setImage(img_stimulus1)\u000a            image_stimulus2_box_B.setPos(image_stimulus2_location)\u000a            image_stimulus2_box_B.setImage(img_stimulus2)\u000a            stimulus1_box_B.setText(stimulus1)\u000a            stimulus1_box_B.setPos(stimulus1_location)\u000a            stimulus2_box_B.setText(stimulus2)\u000a            stimulus2_box_B.setPos(stimulus2_location)\u000a            required_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            required_response_B.status = NOT_STARTED\u000a            feedback_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            feedback_response_B.status = NOT_STARTED\u000a            left_box_B.setText(response_option_left)\u000a            left_box_B.setPos(response_option_left_location)\u000a            right_box_B.setText(response_option_right)\u000a            right_box_B.setPos(response_option_right_location)\u000a            accuracy_feedback_box_B.setPos(accuracy_feedback_location)\u000a            # keep track of which components have finished\u000a            trial_BComponents = []\u000a            trial_BComponents.append(image_stimulus1_box_B)\u000a            trial_BComponents.append(image_stimulus2_box_B)\u000a            trial_BComponents.append(stimulus1_box_B)\u000a            trial_BComponents.append(stimulus2_box_B)\u000a            trial_BComponents.append(required_response_B)\u000a            trial_BComponents.append(feedback_response_B)\u000a            trial_BComponents.append(left_box_B)\u000a            trial_BComponents.append(right_box_B)\u000a            trial_BComponents.append(accuracy_feedback_box_B)\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "trial_B"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = trial_BClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                # Accuracy feedback message&#10;if len(feedback_response_B.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                \u000a                # *image_stimulus1_box_B* updates\u000a                if t >= 0.4 and image_stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *image_stimulus2_box_B* updates\u000a                if t >= 0.4 and image_stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus1_box_B* updates\u000a                if t >= 0.4 and stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus2_box_B* updates\u000a                if t >= 0.4 and stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *required_response_B* updates\u000a                if t >= 0.4 and required_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    required_response_B.tStart = t  # underestimates by a little under one frame\u000a                    required_response_B.frameNStart = frameN  # exact frame index\u000a                    required_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `required_allowed`\u000a                    if not 'required_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(required_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                        else:  required_allowed = eval(required_allowed)\u000a                    # keyboard checking is just starting\u000a                    required_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if required_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if required_response_B.keys == []:  # then this was the first keypress\u000a                            required_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            required_response_B.rt = required_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (required_response_B.keys == str(required_correct)) or (required_response_B.keys == required_correct):\u000a                                required_response_B.corr = 1\u000a                            else:\u000a                                required_response_B.corr = 0\u000a                            # a response ends the routine\u000a                            continueRoutine = False\u000a                \u000a                # *feedback_response_B* updates\u000a                if t >= 0.4 and feedback_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    feedback_response_B.tStart = t  # underestimates by a little under one frame\u000a                    feedback_response_B.frameNStart = frameN  # exact frame index\u000a                    feedback_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `feedback_allowed`\u000a                    if not 'feedback_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(feedback_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                        else:  feedback_allowed = eval(feedback_allowed)\u000a                    # keyboard checking is just starting\u000a                    feedback_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if feedback_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if feedback_response_B.keys == []:  # then this was the first keypress\u000a                            feedback_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            feedback_response_B.rt = feedback_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (feedback_response_B.keys == str(feedback_correct)) or (feedback_response_B.keys == feedback_correct):\u000a                                feedback_response_B.corr = 1\u000a                            else:\u000a                                feedback_response_B.corr = 0\u000a                \u000a                # *left_box_B* updates\u000a                if t >= response_option_onset and left_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    left_box_B.tStart = t  # underestimates by a little under one frame\u000a                    left_box_B.frameNStart = frameN  # exact frame index\u000a                    left_box_B.setAutoDraw(True)\u000a                \u000a                # *right_box_B* updates\u000a                if t >= response_option_onset and right_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    right_box_B.tStart = t  # underestimates by a little under one frame\u000a                    right_box_B.frameNStart = frameN  # exact frame index\u000a                    right_box_B.setAutoDraw(True)\u000a                \u000a                # *accuracy_feedback_box_B* updates\u000a                if t >= 0.4 and accuracy_feedback_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_feedback_box_B.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_feedback_box_B.frameNStart = frameN  # exact frame index\u000a                    accuracy_feedback_box_B.setAutoDraw(True)\u000a                if accuracy_feedback_box_B.status == STARTED:  # only update if being drawn\u000a                    accuracy_feedback_box_B.setText(accuracyFeedback, log=False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in trial_BComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "trial_B"-------\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a            # check responses\u000a            if required_response_B.keys in ['', [], None]:  # No response was made\u000a               required_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(required_correct).lower() == 'none': required_response_B.corr = 1  # correct non-response\u000a               else: required_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for practice_trials_B (TrialHandler)\u000a            practice_trials_B.addData('required_response_B.keys',required_response_B.keys)\u000a            practice_trials_B.addData('required_response_B.corr', required_response_B.corr)\u000a            if required_response_B.keys != None:  # we had a response\u000a                practice_trials_B.addData('required_response_B.rt', required_response_B.rt)\u000a            # check responses\u000a            if feedback_response_B.keys in ['', [], None]:  # No response was made\u000a               feedback_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(feedback_correct).lower() == 'none': feedback_response_B.corr = 1  # correct non-response\u000a               else: feedback_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for practice_trials_B (TrialHandler)\u000a            practice_trials_B.addData('feedback_response_B.keys',feedback_response_B.keys)\u000a            practice_trials_B.addData('feedback_response_B.corr', feedback_response_B.corr)\u000a            if feedback_response_B.keys != None:  # we had a response\u000a                practice_trials_B.addData('feedback_response_B.rt', feedback_response_B.rt)\u000a            # the Routine "trial_B" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            thisExp.nextEntry()\u000a            \u000a        # completed reptitions repeats of 'practice_trials_B'\u000a        \u000a        \u000a        #------Prepare to start Routine "practice_postblock_B"-------\u000a        t = 0\u000a        practice_postblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;prac_block_B_percentage_accuracy = (float(practice_trials_B.data['required_response_B.corr'].count()) - float(practice_trials_B.data['feedback_response_B.corr'].sum())) /  float(practice_trials_B.data['required_response_B.corr'].count()) * 100 &#10;prac_block_B_median_latency = np.median(practice_trials_B.data['required_response_B.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, prac_block_B_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, prac_block_B_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('prac_block_B_percentage_accuracy', prac_block_B_percentage_accuracy)&#10;##thisExp.addData('prac_block_B_median_latency', prac_block_B_median_latency)\u000a        practice_aim_box_B.setText(aim)\u000a        practice_accuracy_box_B.setText(msg_accuracy)\u000a        practice_latency_box_B.setText(msg_latency)\u000a        press_box_prac_B.setText(press_message)\u000a        practice_postblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        practice_postblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        practice_postblock_BComponents = []\u000a        practice_postblock_BComponents.append(practice_aim_box_B)\u000a        practice_postblock_BComponents.append(practice_accuracy_box_B)\u000a        practice_postblock_BComponents.append(practice_latency_box_B)\u000a        practice_postblock_BComponents.append(press_box_prac_B)\u000a        practice_postblock_BComponents.append(practice_postblock_response_B)\u000a        for thisComponent in practice_postblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "practice_postblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = practice_postblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *practice_aim_box_B* updates\u000a            if t >= 0.4 and practice_aim_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_aim_box_B.tStart = t  # underestimates by a little under one frame\u000a                practice_aim_box_B.frameNStart = frameN  # exact frame index\u000a                practice_aim_box_B.setAutoDraw(True)\u000a            \u000a            # *practice_accuracy_box_B* updates\u000a            if t >= 0.4 and practice_accuracy_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_accuracy_box_B.tStart = t  # underestimates by a little under one frame\u000a                practice_accuracy_box_B.frameNStart = frameN  # exact frame index\u000a                practice_accuracy_box_B.setAutoDraw(True)\u000a            \u000a            # *practice_latency_box_B* updates\u000a            if t >= 0.4 and practice_latency_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_latency_box_B.tStart = t  # underestimates by a little under one frame\u000a                practice_latency_box_B.frameNStart = frameN  # exact frame index\u000a                practice_latency_box_B.setAutoDraw(True)\u000a            \u000a            # *press_box_prac_B* updates\u000a            if t >= 0.4 and press_box_prac_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                press_box_prac_B.tStart = t  # underestimates by a little under one frame\u000a                press_box_prac_B.frameNStart = frameN  # exact frame index\u000a                press_box_prac_B.setAutoDraw(True)\u000a            \u000a            # *practice_postblock_response_B* updates\u000a            if t >= 1 and practice_postblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_postblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                practice_postblock_response_B.frameNStart = frameN  # exact frame index\u000a                practice_postblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if practice_postblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in practice_postblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "practice_postblock_B"-------\u000a        for thisComponent in practice_postblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "practice_postblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        practice_Asecond = data.TrialHandler(nReps=Asecond_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='practice_Asecond')\u000a        thisExp.addLoop(practice_Asecond)  # add the loop to the experiment\u000a        thisPractice_Asecond = practice_Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisPractice_Asecond.rgb)\u000a        if thisPractice_Asecond != None:\u000a            for paramName in thisPractice_Asecond.keys():\u000a                exec(paramName + '= thisPractice_Asecond.' + paramName)\u000a        \u000a        for thisPractice_Asecond in practice_Asecond:\u000a            currentLoop = practice_Asecond\u000a            # abbreviate parameter names if possible (e.g. rgb = thisPractice_Asecond.rgb)\u000a            if thisPractice_Asecond != None:\u000a                for paramName in thisPractice_Asecond.keys():\u000a                    exec(paramName + '= thisPractice_Asecond.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            practice_trials_Asecond = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='practice_trials_Asecond')\u000a            thisExp.addLoop(practice_trials_Asecond)  # add the loop to the experiment\u000a            thisPractice_trials_Asecond = practice_trials_Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisPractice_trials_Asecond.rgb)\u000a            if thisPractice_trials_Asecond != None:\u000a                for paramName in thisPractice_trials_Asecond.keys():\u000a                    exec(paramName + '= thisPractice_trials_Asecond.' + paramName)\u000a            \u000a            for thisPractice_trials_Asecond in practice_trials_Asecond:\u000a                currentLoop = practice_trials_Asecond\u000a                # abbreviate parameter names if possible (e.g. rgb = thisPractice_trials_Asecond.rgb)\u000a                if thisPractice_trials_Asecond != None:\u000a                    for paramName in thisPractice_trials_Asecond.keys():\u000a                        exec(paramName + '= thisPractice_trials_Asecond.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Asecond (TrialHandler)\u000a                practice_trials_Asecond.addData('required_response_A.keys',required_response_A.keys)\u000a                practice_trials_Asecond.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    practice_trials_Asecond.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Asecond (TrialHandler)\u000a                practice_trials_Asecond.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                practice_trials_Asecond.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    practice_trials_Asecond.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'practice_trials_Asecond'\u000a            \u000a            \u000a            #------Prepare to start Routine "practice_postblock_A"-------\u000a            t = 0\u000a            practice_postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Afirst.data['required_response_A.corr'].count()) - float(practice_trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Asecond.data['required_response_A.corr'].count()) - float(practice_trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, prac_block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, prac_block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('prac_block_A_percentage_accuracy', prac_block_A_percentage_accuracy)&#10;##thisExp.addData('prac_block_A_median_latency', prac_block_A_median_latency)\u000a            practice_aim_box_A.setText(aim)\u000a            practice_accuracy_box_A.setText(msg_accuracy)\u000a            practice_latency_box_A.setText(msg_latency)\u000a            press_box_prac_A.setText(press_message)\u000a            practice_postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            practice_postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            practice_postblock_AComponents = []\u000a            practice_postblock_AComponents.append(practice_aim_box_A)\u000a            practice_postblock_AComponents.append(practice_accuracy_box_A)\u000a            practice_postblock_AComponents.append(practice_latency_box_A)\u000a            practice_postblock_AComponents.append(press_box_prac_A)\u000a            practice_postblock_AComponents.append(practice_postblock_response_A)\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "practice_postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = practice_postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *practice_aim_box_A* updates\u000a                if t >= 0.4 and practice_aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_aim_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_aim_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_accuracy_box_A* updates\u000a                if t >= 0.4 and practice_accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_latency_box_A* updates\u000a                if t >= 0.4 and practice_latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_latency_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_prac_A* updates\u000a                if t >= 0.4 and press_box_prac_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_prac_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_prac_A.frameNStart = frameN  # exact frame index\u000a                    press_box_prac_A.setAutoDraw(True)\u000a                \u000a                # *practice_postblock_response_A* updates\u000a                if t >= 1 and practice_postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    practice_postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if practice_postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in practice_postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "practice_postblock_A"-------\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "practice_postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Asecond_nReps repeats of 'practice_Asecond'\u000a        \u000a        \u000a        #------Prepare to start Routine "end_practice_blocks"-------\u000a        t = 0\u000a        end_practice_blocksClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Assess if acc and latency mastery criteria were met&#10;if (prac_block_A_percentage_accuracy >= accuracyCriterion) and (prac_block_B_percentage_accuracy >= accuracyCriterion) and (prac_block_A_median_latency <= latencyCriterion) and (prac_block_B_median_latency <= latencyCriterion):&#10;    complete_test_blocks = n_pairs_test_blocks # latter from blocks.xlsx&#10;    practice_blocks.finished = True\u000a        # keep track of which components have finished\u000a        end_practice_blocksComponents = []\u000a        for thisComponent in end_practice_blocksComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "end_practice_blocks"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = end_practice_blocksClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in end_practice_blocksComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "end_practice_blocks"-------\u000a        for thisComponent in end_practice_blocksComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "end_practice_blocks" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a    # completed max_pairs_practice_blocks repeats of 'practice_blocks'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    test_blocks = data.TrialHandler(nReps=complete_test_blocks, method='sequential', \u000a        extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a        trialList=[None],\u000a        seed=None, name='test_blocks')\u000a    thisExp.addLoop(test_blocks)  # add the loop to the experiment\u000a    thisTest_block = test_blocks.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTest_block.rgb)\u000a    if thisTest_block != None:\u000a        for paramName in thisTest_block.keys():\u000a            exec(paramName + '= thisTest_block.' + paramName)\u000a    \u000a    for thisTest_block in test_blocks:\u000a        currentLoop = test_blocks\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTest_block.rgb)\u000a        if thisTest_block != None:\u000a            for paramName in thisTest_block.keys():\u000a                exec(paramName + '= thisTest_block.' + paramName)\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        Afirst = data.TrialHandler(nReps=Afirst_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='Afirst')\u000a        thisExp.addLoop(Afirst)  # add the loop to the experiment\u000a        thisAfirst = Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisAfirst.rgb)\u000a        if thisAfirst != None:\u000a            for paramName in thisAfirst.keys():\u000a                exec(paramName + '= thisAfirst.' + paramName)\u000a        \u000a        for thisAfirst in Afirst:\u000a            currentLoop = Afirst\u000a            # abbreviate parameter names if possible (e.g. rgb = thisAfirst.rgb)\u000a            if thisAfirst != None:\u000a                for paramName in thisAfirst.keys():\u000a                    exec(paramName + '= thisAfirst.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            trials_Afirst = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='trials_Afirst')\u000a            thisExp.addLoop(trials_Afirst)  # add the loop to the experiment\u000a            thisTrials_Afirst = trials_Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisTrials_Afirst.rgb)\u000a            if thisTrials_Afirst != None:\u000a                for paramName in thisTrials_Afirst.keys():\u000a                    exec(paramName + '= thisTrials_Afirst.' + paramName)\u000a            \u000a            for thisTrials_Afirst in trials_Afirst:\u000a                currentLoop = trials_Afirst\u000a                # abbreviate parameter names if possible (e.g. rgb = thisTrials_Afirst.rgb)\u000a                if thisTrials_Afirst != None:\u000a                    for paramName in thisTrials_Afirst.keys():\u000a                        exec(paramName + '= thisTrials_Afirst.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Afirst (TrialHandler)\u000a                trials_Afirst.addData('required_response_A.keys',required_response_A.keys)\u000a                trials_Afirst.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    trials_Afirst.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Afirst (TrialHandler)\u000a                trials_Afirst.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                trials_Afirst.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    trials_Afirst.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'trials_Afirst'\u000a            \u000a            \u000a            #------Prepare to start Routine "postblock_A"-------\u000a            t = 0\u000a            postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'): &#10;    block_A_percentage_accuracy = (float(trials_Afirst.data['required_response_A.corr'].count()) - float(trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'): &#10;    block_A_percentage_accuracy = (float(trials_Asecond.data['required_response_A.corr'].count()) - float(trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('block_A_percentage_accuracy', block_A_percentage_accuracy)&#10;##thisExp.addData('block_A_median_latency', block_A_median_latency)\u000a            aim_box_A.setText(aim)\u000a            accuracy_box_A.setText(msg_accuracy)\u000a            latency_box_A.setText(msg_latency)\u000a            press_box_A.setText(press_message)\u000a            postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            postblock_AComponents = []\u000a            postblock_AComponents.append(aim_box_A)\u000a            postblock_AComponents.append(accuracy_box_A)\u000a            postblock_AComponents.append(latency_box_A)\u000a            postblock_AComponents.append(press_box_A)\u000a            postblock_AComponents.append(postblock_response_A)\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *aim_box_A* updates\u000a                if t >= 0.4 and aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    aim_box_A.frameNStart = frameN  # exact frame index\u000a                    aim_box_A.setAutoDraw(True)\u000a                \u000a                # *accuracy_box_A* updates\u000a                if t >= 0.4 and accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *latency_box_A* updates\u000a                if t >= 0.4 and latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    latency_box_A.frameNStart = frameN  # exact frame index\u000a                    latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_A* updates\u000a                if t >= 0.4 and press_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_A.frameNStart = frameN  # exact frame index\u000a                    press_box_A.setAutoDraw(True)\u000a                \u000a                # *postblock_response_A* updates\u000a                if t >= 1 and postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "postblock_A"-------\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Afirst_nReps repeats of 'Afirst'\u000a        \u000a        \u000a        #------Prepare to start Routine "preblock_B"-------\u000a        t = 0\u000a        preblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)\u000a        rule_box_B.setText(rule_B)\u000a        preblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        preblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        preblock_BComponents = []\u000a        preblock_BComponents.append(rule_box_B)\u000a        preblock_BComponents.append(preblock_response_B)\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "preblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = preblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *rule_box_B* updates\u000a            if t >= 0.4 and rule_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rule_box_B.tStart = t  # underestimates by a little under one frame\u000a                rule_box_B.frameNStart = frameN  # exact frame index\u000a                rule_box_B.setAutoDraw(True)\u000a            \u000a            # *preblock_response_B* updates\u000a            if t >= 1 and preblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                preblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                preblock_response_B.frameNStart = frameN  # exact frame index\u000a                preblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if preblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in preblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "preblock_B"-------\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "preblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        trials_B = data.TrialHandler(nReps=reptitions, method='random', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=data.importConditions('block_layout.xlsx'),\u000a            seed=None, name='trials_B')\u000a        thisExp.addLoop(trials_B)  # add the loop to the experiment\u000a        thisTrials_B = trials_B.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisTrials_B.rgb)\u000a        if thisTrials_B != None:\u000a            for paramName in thisTrials_B.keys():\u000a                exec(paramName + '= thisTrials_B.' + paramName)\u000a        \u000a        for thisTrials_B in trials_B:\u000a            currentLoop = trials_B\u000a            # abbreviate parameter names if possible (e.g. rgb = thisTrials_B.rgb)\u000a            if thisTrials_B != None:\u000a                for paramName in thisTrials_B.keys():\u000a                    exec(paramName + '= thisTrials_B.' + paramName)\u000a            \u000a            #------Prepare to start Routine "trial_B"-------\u000a            t = 0\u000a            trial_BClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'\u000a            image_stimulus1_box_B.setPos(image_stimulus1_location)\u000a            image_stimulus1_box_B.setImage(img_stimulus1)\u000a            image_stimulus2_box_B.setPos(image_stimulus2_location)\u000a            image_stimulus2_box_B.setImage(img_stimulus2)\u000a            stimulus1_box_B.setText(stimulus1)\u000a            stimulus1_box_B.setPos(stimulus1_location)\u000a            stimulus2_box_B.setText(stimulus2)\u000a            stimulus2_box_B.setPos(stimulus2_location)\u000a            required_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            required_response_B.status = NOT_STARTED\u000a            feedback_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            feedback_response_B.status = NOT_STARTED\u000a            left_box_B.setText(response_option_left)\u000a            left_box_B.setPos(response_option_left_location)\u000a            right_box_B.setText(response_option_right)\u000a            right_box_B.setPos(response_option_right_location)\u000a            accuracy_feedback_box_B.setPos(accuracy_feedback_location)\u000a            # keep track of which components have finished\u000a            trial_BComponents = []\u000a            trial_BComponents.append(image_stimulus1_box_B)\u000a            trial_BComponents.append(image_stimulus2_box_B)\u000a            trial_BComponents.append(stimulus1_box_B)\u000a            trial_BComponents.append(stimulus2_box_B)\u000a            trial_BComponents.append(required_response_B)\u000a            trial_BComponents.append(feedback_response_B)\u000a            trial_BComponents.append(left_box_B)\u000a            trial_BComponents.append(right_box_B)\u000a            trial_BComponents.append(accuracy_feedback_box_B)\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "trial_B"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = trial_BClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                # Accuracy feedback message&#10;if len(feedback_response_B.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                \u000a                # *image_stimulus1_box_B* updates\u000a                if t >= 0.4 and image_stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *image_stimulus2_box_B* updates\u000a                if t >= 0.4 and image_stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus1_box_B* updates\u000a                if t >= 0.4 and stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus2_box_B* updates\u000a                if t >= 0.4 and stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *required_response_B* updates\u000a                if t >= 0.4 and required_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    required_response_B.tStart = t  # underestimates by a little under one frame\u000a                    required_response_B.frameNStart = frameN  # exact frame index\u000a                    required_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `required_allowed`\u000a                    if not 'required_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(required_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                        else:  required_allowed = eval(required_allowed)\u000a                    # keyboard checking is just starting\u000a                    required_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if required_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if required_response_B.keys == []:  # then this was the first keypress\u000a                            required_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            required_response_B.rt = required_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (required_response_B.keys == str(required_correct)) or (required_response_B.keys == required_correct):\u000a                                required_response_B.corr = 1\u000a                            else:\u000a                                required_response_B.corr = 0\u000a                            # a response ends the routine\u000a                            continueRoutine = False\u000a                \u000a                # *feedback_response_B* updates\u000a                if t >= 0.4 and feedback_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    feedback_response_B.tStart = t  # underestimates by a little under one frame\u000a                    feedback_response_B.frameNStart = frameN  # exact frame index\u000a                    feedback_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `feedback_allowed`\u000a                    if not 'feedback_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(feedback_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                        else:  feedback_allowed = eval(feedback_allowed)\u000a                    # keyboard checking is just starting\u000a                    feedback_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if feedback_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if feedback_response_B.keys == []:  # then this was the first keypress\u000a                            feedback_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            feedback_response_B.rt = feedback_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (feedback_response_B.keys == str(feedback_correct)) or (feedback_response_B.keys == feedback_correct):\u000a                                feedback_response_B.corr = 1\u000a                            else:\u000a                                feedback_response_B.corr = 0\u000a                \u000a                # *left_box_B* updates\u000a                if t >= response_option_onset and left_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    left_box_B.tStart = t  # underestimates by a little under one frame\u000a                    left_box_B.frameNStart = frameN  # exact frame index\u000a                    left_box_B.setAutoDraw(True)\u000a                \u000a                # *right_box_B* updates\u000a                if t >= response_option_onset and right_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    right_box_B.tStart = t  # underestimates by a little under one frame\u000a                    right_box_B.frameNStart = frameN  # exact frame index\u000a                    right_box_B.setAutoDraw(True)\u000a                \u000a                # *accuracy_feedback_box_B* updates\u000a                if t >= 0.4 and accuracy_feedback_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_feedback_box_B.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_feedback_box_B.frameNStart = frameN  # exact frame index\u000a                    accuracy_feedback_box_B.setAutoDraw(True)\u000a                if accuracy_feedback_box_B.status == STARTED:  # only update if being drawn\u000a                    accuracy_feedback_box_B.setText(accuracyFeedback, log=False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in trial_BComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "trial_B"-------\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a            # check responses\u000a            if required_response_B.keys in ['', [], None]:  # No response was made\u000a               required_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(required_correct).lower() == 'none': required_response_B.corr = 1  # correct non-response\u000a               else: required_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for trials_B (TrialHandler)\u000a            trials_B.addData('required_response_B.keys',required_response_B.keys)\u000a            trials_B.addData('required_response_B.corr', required_response_B.corr)\u000a            if required_response_B.keys != None:  # we had a response\u000a                trials_B.addData('required_response_B.rt', required_response_B.rt)\u000a            # check responses\u000a            if feedback_response_B.keys in ['', [], None]:  # No response was made\u000a               feedback_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(feedback_correct).lower() == 'none': feedback_response_B.corr = 1  # correct non-response\u000a               else: feedback_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for trials_B (TrialHandler)\u000a            trials_B.addData('feedback_response_B.keys',feedback_response_B.keys)\u000a            trials_B.addData('feedback_response_B.corr', feedback_response_B.corr)\u000a            if feedback_response_B.keys != None:  # we had a response\u000a                trials_B.addData('feedback_response_B.rt', feedback_response_B.rt)\u000a            # the Routine "trial_B" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            thisExp.nextEntry()\u000a            \u000a        # completed reptitions repeats of 'trials_B'\u000a        \u000a        \u000a        #------Prepare to start Routine "postblock_B"-------\u000a        t = 0\u000a        postblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;block_B_percentage_accuracy = (float(trials_B.data['required_response_B.corr'].count()) - float(trials_B.data['feedback_response_B.corr'].sum())) /  float(trials_B.data['required_response_B.corr'].count()) * 100 &#10;block_B_median_latency = np.median(trials_B.data['required_response_B.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, block_B_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, block_B_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('block_B_percentage_accuracy', block_B_percentage_accuracy)&#10;##thisExp.addData('block_B_median_latency', block_B_median_latency)\u000a        aim_box_B.setText(aim)\u000a        accuracy_box_B.setText(msg_accuracy)\u000a        latency_box_B.setText(msg_latency)\u000a        press_box_B.setText(press_message)\u000a        postblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        postblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        postblock_BComponents = []\u000a        postblock_BComponents.append(aim_box_B)\u000a        postblock_BComponents.append(accuracy_box_B)\u000a        postblock_BComponents.append(latency_box_B)\u000a        postblock_BComponents.append(press_box_B)\u000a        postblock_BComponents.append(postblock_response_B)\u000a        for thisComponent in postblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "postblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = postblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *aim_box_B* updates\u000a            if t >= 0.4 and aim_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                aim_box_B.tStart = t  # underestimates by a little under one frame\u000a                aim_box_B.frameNStart = frameN  # exact frame index\u000a                aim_box_B.setAutoDraw(True)\u000a            \u000a            # *accuracy_box_B* updates\u000a            if t >= 0.4 and accuracy_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                accuracy_box_B.tStart = t  # underestimates by a little under one frame\u000a                accuracy_box_B.frameNStart = frameN  # exact frame index\u000a                accuracy_box_B.setAutoDraw(True)\u000a            \u000a            # *latency_box_B* updates\u000a            if t >= 0.4 and latency_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                latency_box_B.tStart = t  # underestimates by a little under one frame\u000a                latency_box_B.frameNStart = frameN  # exact frame index\u000a                latency_box_B.setAutoDraw(True)\u000a            \u000a            # *press_box_B* updates\u000a            if t >= 0.4 and press_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                press_box_B.tStart = t  # underestimates by a little under one frame\u000a                press_box_B.frameNStart = frameN  # exact frame index\u000a                press_box_B.setAutoDraw(True)\u000a            \u000a            # *postblock_response_B* updates\u000a            if t >= 1 and postblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                postblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                postblock_response_B.frameNStart = frameN  # exact frame index\u000a                postblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if postblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in postblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "postblock_B"-------\u000a        for thisComponent in postblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "postblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        Asecond = data.TrialHandler(nReps=Asecond_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='Asecond')\u000a        thisExp.addLoop(Asecond)  # add the loop to the experiment\u000a        thisAsecond = Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisAsecond.rgb)\u000a        if thisAsecond != None:\u000a            for paramName in thisAsecond.keys():\u000a                exec(paramName + '= thisAsecond.' + paramName)\u000a        \u000a        for thisAsecond in Asecond:\u000a            currentLoop = Asecond\u000a            # abbreviate parameter names if possible (e.g. rgb = thisAsecond.rgb)\u000a            if thisAsecond != None:\u000a                for paramName in thisAsecond.keys():\u000a                    exec(paramName + '= thisAsecond.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            trials_Asecond = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='trials_Asecond')\u000a            thisExp.addLoop(trials_Asecond)  # add the loop to the experiment\u000a            thisTrials_Asecond = trials_Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisTrials_Asecond.rgb)\u000a            if thisTrials_Asecond != None:\u000a                for paramName in thisTrials_Asecond.keys():\u000a                    exec(paramName + '= thisTrials_Asecond.' + paramName)\u000a            \u000a            for thisTrials_Asecond in trials_Asecond:\u000a                currentLoop = trials_Asecond\u000a                # abbreviate parameter names if possible (e.g. rgb = thisTrials_Asecond.rgb)\u000a                if thisTrials_Asecond != None:\u000a                    for paramName in thisTrials_Asecond.keys():\u000a                        exec(paramName + '= thisTrials_Asecond.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Asecond (TrialHandler)\u000a                trials_Asecond.addData('required_response_A.keys',required_response_A.keys)\u000a                trials_Asecond.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    trials_Asecond.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Asecond (TrialHandler)\u000a                trials_Asecond.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                trials_Asecond.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    trials_Asecond.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'trials_Asecond'\u000a            \u000a            \u000a            #------Prepare to start Routine "postblock_A"-------\u000a            t = 0\u000a            postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'): &#10;    block_A_percentage_accuracy = (float(trials_Afirst.data['required_response_A.corr'].count()) - float(trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'): &#10;    block_A_percentage_accuracy = (float(trials_Asecond.data['required_response_A.corr'].count()) - float(trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('block_A_percentage_accuracy', block_A_percentage_accuracy)&#10;##thisExp.addData('block_A_median_latency', block_A_median_latency)\u000a            aim_box_A.setText(aim)\u000a            accuracy_box_A.setText(msg_accuracy)\u000a            latency_box_A.setText(msg_latency)\u000a            press_box_A.setText(press_message)\u000a            postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            postblock_AComponents = []\u000a            postblock_AComponents.append(aim_box_A)\u000a            postblock_AComponents.append(accuracy_box_A)\u000a            postblock_AComponents.append(latency_box_A)\u000a            postblock_AComponents.append(press_box_A)\u000a            postblock_AComponents.append(postblock_response_A)\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *aim_box_A* updates\u000a                if t >= 0.4 and aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    aim_box_A.frameNStart = frameN  # exact frame index\u000a                    aim_box_A.setAutoDraw(True)\u000a                \u000a                # *accuracy_box_A* updates\u000a                if t >= 0.4 and accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *latency_box_A* updates\u000a                if t >= 0.4 and latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    latency_box_A.frameNStart = frameN  # exact frame index\u000a                    latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_A* updates\u000a                if t >= 0.4 and press_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_A.frameNStart = frameN  # exact frame index\u000a                    press_box_A.setAutoDraw(True)\u000a                \u000a                # *postblock_response_A* updates\u000a                if t >= 1 and postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "postblock_A"-------\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Asecond_nReps repeats of 'Asecond'\u000a        \u000a    # completed complete_test_blocks repeats of 'test_blocks'\u000a    \u000a    \u000a    #------Prepare to start Routine "end"-------\u000a    t = 0\u000a    endClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    end_box.setText(end_message)\u000a    end_response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    end_response.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    endComponents = []\u000a    endComponents.append(end_box)\u000a    endComponents.append(end_response)\u000a    for thisComponent in endComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "end"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = endClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *end_box* updates\u000a        if t >= 0.4 and end_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            end_box.tStart = t  # underestimates by a little under one frame\u000a            end_box.frameNStart = frameN  # exact frame index\u000a            end_box.setAutoDraw(True)\u000a        \u000a        # *end_response* updates\u000a        if t >= .4 and end_response.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            end_response.tStart = t  # underestimates by a little under one frame\u000a            end_response.frameNStart = frameN  # exact frame index\u000a            end_response.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if end_response.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['return'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in endComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "end"-------\u000a    for thisComponent in endComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "end" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'task'\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p37
sS'thisTrial'
p38
g1
(cpsychopy.data
TrialType
p39
c__builtin__
dict
p40
(dp41
Vresponse_option_left_location
p42
(lp43
F-0.29999999999999999
aF-0.59999999999999998
asVaccuracyCriterion
p44
F0.80000000000000004
sVresponse_option_right_location
p45
(lp46
F0.29999999999999999
aF-0.59999999999999998
asVseconds
p47
g47
sVpercentCorrect
p48
VPorcentaje correcto
p49
sVend_message
p50
VGracias por participar
p51
sVimage_stimulus1_location
p52
(lp53
I0
aF0.29999999999999999
asVrule_A
p54
VA continuacin, usted observar en la pantalla 2 palabras y de acuerdo a su criterio deber reponder si esta de acuerdo o no. Marque las teclas de las vocales (e, i). Entonces, s est: En desacuerdo (e) y s est De acuerdo (i) 
p55
sVspeed
p56
VSpeed:
p57
sVaccuracy_feedback_location
p58
(lp59
I0
aF-0.69999999999999996
asVmoving_response_options
p60
I0
sVstimulus_file
p61
Vstimuli.xlsx
p62
sVimage_stimulus2_location
p63
(lp64
I0
aF-0.29999999999999999
asVrule_B
p65
VA continuacin  en la pantalla vera 2 palabras las cuales a su jucio debera reponder si son similares marcando la letra (e) y si son opuestas marcando la letra  (i)
p66
sVpress_message
p67
VPresione la tecla (e) o (i) para continuar
p68
sVintro_message
p69
VBienvenido! Gracias por su tiempo. Por favor, siga las intruciones en pantalla.\u000aOprima (i) para continuar
p70
sVaim
p71
Vacertos >80% y <2 segundos
p72
sVresponse_option_B
p73
VEn desacuerdo
p74
sVresponse_option_A
p75
VDe acuerdo
p76
sVstimulus1_location
p77
(lp78
I0
aF0.20000000000000001
asVstimulus2_location
p79
(lp80
I0
aF-0.20000000000000001
asVn_pairs_test_blocks
p81
I3
sVmax_pairs_practice_blocks
p82
I2
sVlatencyCriterion
p83
I2
sVaccuracy
p84
VAccuracy:
p85
stRp86
sS'_exp'
p87
I278396016
sg11
S'task'
p88
sg6
S'C:\\Users\\jeiso\\Documents\\OpenSourceIRAP-master\\Open Source IRAP_lastrun.py'
p89
sS'thisRepN'
p90
I0
sg15
I01
sg16
g17
sS'data'
p91
g1
(cpsychopy.data
DataHandler
p92
g40
(dp93
S'ran'
p94
cnumpy.ma.core
_mareconstruct
p95
(cnumpy.ma.core
MaskedArray
p96
cnumpy
ndarray
p97
(I0
tp98
S'b'
tRp99
(I1
(I1
I1
tg24
(S'f4'
I0
I1
tRp100
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?'
S'\x00'
NtbsS'order'
p101
g95
(g96
g97
g98
S'b'
tRp102
(I1
(I1
I1
tg100
I00
S'\x00\x00\x00\x00'
S'\x00'
NtbstRp103
(dp104
S'isNumeric'
p105
(dp106
g94
I01
sg101
I01
ssS'trials'
p107
g34
sS'dataTypes'
p108
(lp109
g94
ag101
asS'dataShape'
p110
(lp111
I1
aI1
asbsS'method'
p112
S'sequential'
p113
sS'sequenceIndices'
p114
cnumpy.core.multiarray
_reconstruct
p115
(g97
(I0
tS'b'
tRp116
(I1
(I1
I1
tg24
(S'i4'
I0
I1
tRp117
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00'
tbsS'finished'
p118
I00
sS'nReps'
p119
I1
sS'nRemaining'
p120
I0
sS'trialList'
p121
(lp122
g86
asS'seed'
p123
NsS'thisIndex'
p124
g23
(g117
S'\x00\x00\x00\x00'
tRp125
sS'thisN'
p126
I0
sS'thisTrialN'
p127
I0
sS'nTotal'
p128
I1
sS'_warnUseOfNext'
p129
I01
sbag1
(g33
g3
NtRp130
(dp131
g36
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.85.2), April 10, 2022, at 12:39\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport sys # to get file system encoding\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__)).decode(sys.getfilesystemencoding())\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'IRAP'  # from the Builder filename that created this script\u000aexpInfo = {u'gender': u'', u'age': u'', u'participant': u'', u'StartingBlock': u'a', u'UseMonkey': u'n'}\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + u'data' + os.path.sep + '%s_%s' %(expInfo['participant'], expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.ERROR)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1504, 1003), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor=u'testMonitor', color=u'black', colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    units='norm')\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "instructions"\u000ainstructionsClock = core.Clock()\u000a# Dependencies&#10;&#10;from psychopy.hardware.emulator import ResponseEmulator  #for response emulator&#10;import itertools  # for flattening lists of lists into lists&#10;import random  # for shuffling lists&#10;&#10;# Functions&#10;&#10;# Convert string to boolean.&#10;# Take any likely input from the task.xlsx file and convert to a boolean. This helps to idiot-proof the excel files.&#10;def string_to_booleanl(v):&#10;  return v.lower() in ("yes", "true", "TRUE", "True", "t", "T", 1)&#10;&#10;# Trial generation function&#10;def generate_trials(trial_type_column, multiplier, shuffle_list):&#10;    """Generate a shuffled list of stimuli exemplars from a column in an excel stimuli file""" &#10;    a = dict()  # declare a dict to be populated&#10;    for i in range(len(exemplars)):&#10;        a[i] = [exemplars[i][trial_type_column]] * multiplier  # populate the dict from vertical reads of the conditions&#10;    a = a.values()  # extract only values (and not keys) from the list of dicts&#10;    a = list(itertools.chain(*a))  # flatten the list of dicts into a list&#10;    if shuffle_list == True:&#10;        random.shuffle(a)  # shuffle this list, so that it can be drawn from by the trials&#10;    return a&#10;&#10;&#10;# Determine variables based on dialogue box&#10;&#10;# auto response monkey&#10;if str(expInfo['UseMonkey']) == 'y' or str(expInfo['UseMonkey']) == 'Y' or str(expInfo['UseMonkey']) == 'yes' or str(expInfo['UseMonkey']) == 't' or str(expInfo['UseMonkey']) == 'true' or str(expInfo['UseMonkey']) == 'True' or str(expInfo['UseMonkey']) == 'TRUE':&#10;    Monkey = True&#10;else:&#10;    Monkey = False&#10;&#10;# starting block&#10;if str(expInfo['StartingBlock']) == 'a' or str(expInfo['StartingBlock']) == 'A':&#10;    starting_block = 'a'&#10;    Afirst_nReps = 1&#10;    Asecond_nReps = 0&#10;elif str(expInfo['StartingBlock']) == 'b' or str(expInfo['StartingBlock']) == 'B':&#10;    starting_block = 'b'&#10;    Afirst_nReps = 0&#10;    Asecond_nReps = 1&#10;\u000aintro_box = visual.TextStim(win=win, ori=0, name='intro_box',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "practice_postblock_A"\u000apractice_postblock_AClock = core.Clock()\u000a\u000apractice_aim_box_A = visual.TextStim(win=win, ori=0, name='practice_aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_accuracy_box_A = visual.TextStim(win=win, ori=0, name='practice_accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_latency_box_A = visual.TextStim(win=win, ori=0, name='practice_latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_prac_A = visual.TextStim(win=win, ori=0, name='press_box_prac_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_B"\u000apreblock_BClock = core.Clock()\u000a\u000arule_box_B = visual.TextStim(win=win, ori=0, name='rule_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='cyan', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_B"\u000atrial_BClock = core.Clock()\u000a#msg variable just needs some value at start&#10;accuracyFeedback=''\u000aimage_stimulus1_box_B = visual.ImageStim(win=win, name='image_stimulus1_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_B = visual.ImageStim(win=win, name='image_stimulus2_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_B = visual.TextStim(win=win, ori=0, name='stimulus1_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_B = visual.TextStim(win=win, ori=0, name='stimulus2_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_B = visual.TextStim(win=win, ori=0, name='left_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_B = visual.TextStim(win=win, ori=0, name='right_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_B = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "practice_postblock_B"\u000apractice_postblock_BClock = core.Clock()\u000a\u000apractice_aim_box_B = visual.TextStim(win=win, ori=0, name='practice_aim_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_accuracy_box_B = visual.TextStim(win=win, ori=0, name='practice_accuracy_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_latency_box_B = visual.TextStim(win=win, ori=0, name='practice_latency_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_prac_B = visual.TextStim(win=win, ori=0, name='press_box_prac_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "practice_postblock_A"\u000apractice_postblock_AClock = core.Clock()\u000a\u000apractice_aim_box_A = visual.TextStim(win=win, ori=0, name='practice_aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000apractice_accuracy_box_A = visual.TextStim(win=win, ori=0, name='practice_accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000apractice_latency_box_A = visual.TextStim(win=win, ori=0, name='practice_latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_prac_A = visual.TextStim(win=win, ori=0, name='press_box_prac_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "end_practice_blocks"\u000aend_practice_blocksClock = core.Clock()\u000a# by default, don't do test blocks. Change elsewhere if mastery criteria are met.&#10;complete_test_blocks = 0\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "postblock_A"\u000apostblock_AClock = core.Clock()\u000a\u000aaim_box_A = visual.TextStim(win=win, ori=0, name='aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aaccuracy_box_A = visual.TextStim(win=win, ori=0, name='accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000alatency_box_A = visual.TextStim(win=win, ori=0, name='latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_A = visual.TextStim(win=win, ori=0, name='press_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_B"\u000apreblock_BClock = core.Clock()\u000a\u000arule_box_B = visual.TextStim(win=win, ori=0, name='rule_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='cyan', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_B"\u000atrial_BClock = core.Clock()\u000a#msg variable just needs some value at start&#10;accuracyFeedback=''\u000aimage_stimulus1_box_B = visual.ImageStim(win=win, name='image_stimulus1_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_B = visual.ImageStim(win=win, name='image_stimulus2_box_B',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_B = visual.TextStim(win=win, ori=0, name='stimulus1_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_B = visual.TextStim(win=win, ori=0, name='stimulus2_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_B = visual.TextStim(win=win, ori=0, name='left_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_B = visual.TextStim(win=win, ori=0, name='right_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_B = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "postblock_B"\u000apostblock_BClock = core.Clock()\u000a\u000aaim_box_B = visual.TextStim(win=win, ori=0, name='aim_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aaccuracy_box_B = visual.TextStim(win=win, ori=0, name='accuracy_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000alatency_box_B = visual.TextStim(win=win, ori=0, name='latency_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_B = visual.TextStim(win=win, ori=0, name='press_box_B',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "preblock_A"\u000apreblock_AClock = core.Clock()\u000a# msg variable just needs some value at start&#10;accuracyFeedback=''&#10;\u000arule_box_A = visual.TextStim(win=win, ori=0, name='rule_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=1.5,\u000a    color='orange', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000a\u000a# Initialize components for Routine "trial_A"\u000atrial_AClock = core.Clock()\u000a\u000aimage_stimulus1_box_A = visual.ImageStim(win=win, name='image_stimulus1_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-1.0)\u000aimage_stimulus2_box_A = visual.ImageStim(win=win, name='image_stimulus2_box_A',\u000a    image='sin', mask=None,\u000a    ori=0, pos=[0,0], size=[0.5, 0.5],\u000a    color=[1,1,1], colorSpace='rgb', opacity=1,\u000a    flipHoriz=False, flipVert=False,\u000a    texRes=128, interpolate=True, depth=-2.0)\u000astimulus1_box_A = visual.TextStim(win=win, ori=0, name='stimulus1_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000astimulus2_box_A = visual.TextStim(win=win, ori=0, name='stimulus2_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000aleft_box_A = visual.TextStim(win=win, ori=0, name='left_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-7.0)\u000aright_box_A = visual.TextStim(win=win, ori=0, name='right_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-8.0)\u000aaccuracy_feedback_box_A = visual.TextStim(win=win, ori=0, name='accuracy_feedback_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0,0], height=0.2, wrapWidth=None,\u000a    color='red', colorSpace='rgb', opacity=1,\u000a    depth=-9.0)\u000a\u000a# Initialize components for Routine "postblock_A"\u000apostblock_AClock = core.Clock()\u000a\u000aaim_box_A = visual.TextStim(win=win, ori=0, name='aim_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-1.0)\u000aaccuracy_box_A = visual.TextStim(win=win, ori=0, name='accuracy_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-2.0)\u000alatency_box_A = visual.TextStim(win=win, ori=0, name='latency_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.2], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-3.0)\u000apress_box_A = visual.TextStim(win=win, ori=0, name='press_box_A',\u000a    text='default text',    font='Arial',\u000a    pos=[0, -0.5], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=-4.0)\u000a\u000a# Initialize components for Routine "end"\u000aendClock = core.Clock()\u000aend_box = visual.TextStim(win=win, ori=0, name='end_box',\u000a    text='default text',    font='Arial',\u000a    pos=[0, 0], height=0.1, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask = data.TrialHandler(nReps=1, method='sequential', \u000a    extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a    trialList=data.importConditions('task.xlsx'),\u000a    seed=None, name='task')\u000athisExp.addLoop(task)  # add the loop to the experiment\u000athisTask = task.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask.rgb)\u000aif thisTask != None:\u000a    for paramName in thisTask.keys():\u000a        exec(paramName + '= thisTask.' + paramName)\u000a\u000afor thisTask in task:\u000a    currentLoop = task\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask.rgb)\u000a    if thisTask != None:\u000a        for paramName in thisTask.keys():\u000a            exec(paramName + '= thisTask.' + paramName)\u000a    \u000a    #------Prepare to start Routine "instructions"-------\u000a    t = 0\u000a    instructionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # ResponseEmulator&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Create sufficiently long lists of stimuli&#10;"""&#10;This allows us to keep the stimuli in an excel file across multiple lines, and to present them based on the categories &#10;set by the 'layout.xlsx' file. This allows for shuffled (counterbalanced pseudorandom) presentation of the stimuli examplars &#10;as well as the categories. &#10;&#10;The method to do this below is to first declare a dictionary to be populated from the exemplars conditions, but not in the usual way. &#10;Usually, psychopy would read across columns. If the stimuli were entered as a list within the excel file (e.g., ['male', 'female']) &#10;rather on seperate rows as they are now all we would have to do is multiply the length of the list to get enough exemplars. However, &#10;I wanted the stimuli file to be as use friendly as possible, so instead the below code allows you to enter the exemplars on seperate&#10;rows, and then populates the dict vertically from the rows. &#10;"""&#10;# Import stimuli exemplars&#10;exemplars = data.importConditions(stimulus_file)  # Import stimuli exemplars. stimulus_file is defined in task.xlsx&#10;&#10;# Determine nReps of trials loop based on number of exemplars&#10;reptitions = len(exemplars)&#10;&#10;&#10;# Generate a first, unshuffled list of the stimuli exemplars for saving to output file&#10;&#10;# 1. generate: no shuffling, multiplier = 1.&#10;labelA_stimuli_for_output = generate_trials('labelA_stimuli', 1, False)  # function and variable determined at begin exp.&#10;labelB_stimuli_for_output = generate_trials('labelB_stimuli', 1, False)&#10;targetA_stimuli_for_output = generate_trials('targetA_stimuli', 1, False)&#10;targetB_stimuli_for_output = generate_trials('targetB_stimuli', 1, False)&#10;labelA_image_stimuli_for_output = generate_trials('labelA_image_stimuli', 1, False)&#10;labelB_image_stimuli_for_output = generate_trials('labelB_image_stimuli', 1, False)&#10;targetA_image_stimuli_for_output = generate_trials('targetA_image_stimuli', 1, False)&#10;targetB_image_stimuli_for_output = generate_trials('targetB_image_stimuli', 1, False)&#10;&#10;# 2. save these lists to the trial handler to be written to csv&#10;thisExp.addData('labelA_stimuli_for_output', labelA_stimuli_for_output)&#10;thisExp.addData('labelB_stimuli_for_output', labelB_stimuli_for_output)&#10;thisExp.addData('targetA_stimuli_for_output', targetA_stimuli_for_output)&#10;thisExp.addData('targetB_stimuli_for_output', targetB_stimuli_for_output)&#10;thisExp.addData('labelA_image_stimuli_for_output', labelA_image_stimuli_for_output)&#10;thisExp.addData('labelB_image_stimuli_for_output', labelB_image_stimuli_for_output)&#10;thisExp.addData('targetA_image_stimuli_for_output', targetA_image_stimuli_for_output)&#10;thisExp.addData('targetB_image_stimuli_for_output', targetB_image_stimuli_for_output)\u000a    intro_box.setText(intro_message)\u000a    intro_resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    intro_resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    instructionsComponents = []\u000a    instructionsComponents.append(intro_box)\u000a    instructionsComponents.append(intro_resp)\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "instructions"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = instructionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *intro_box* updates\u000a        if t >= 0.4 and intro_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            intro_box.tStart = t  # underestimates by a little under one frame\u000a            intro_box.frameNStart = frameN  # exact frame index\u000a            intro_box.setAutoDraw(True)\u000a        \u000a        # *intro_resp* updates\u000a        if t >= 1 and intro_resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            intro_resp.tStart = t  # underestimates by a little under one frame\u000a            intro_resp.frameNStart = frameN  # exact frame index\u000a            intro_resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if intro_resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['e', 'i'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in instructionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "instructions"-------\u000a    for thisComponent in instructionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    \u000a    # the Routine "instructions" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    practice_blocks = data.TrialHandler(nReps=max_pairs_practice_blocks, method='sequential', \u000a        extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a        trialList=[None],\u000a        seed=None, name='practice_blocks')\u000a    thisExp.addLoop(practice_blocks)  # add the loop to the experiment\u000a    thisPractice_block = practice_blocks.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisPractice_block.rgb)\u000a    if thisPractice_block != None:\u000a        for paramName in thisPractice_block.keys():\u000a            exec(paramName + '= thisPractice_block.' + paramName)\u000a    \u000a    for thisPractice_block in practice_blocks:\u000a        currentLoop = practice_blocks\u000a        # abbreviate parameter names if possible (e.g. rgb = thisPractice_block.rgb)\u000a        if thisPractice_block != None:\u000a            for paramName in thisPractice_block.keys():\u000a                exec(paramName + '= thisPractice_block.' + paramName)\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        practice_Afirst = data.TrialHandler(nReps=Afirst_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='practice_Afirst')\u000a        thisExp.addLoop(practice_Afirst)  # add the loop to the experiment\u000a        thisPractice_Afirst = practice_Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisPractice_Afirst.rgb)\u000a        if thisPractice_Afirst != None:\u000a            for paramName in thisPractice_Afirst.keys():\u000a                exec(paramName + '= thisPractice_Afirst.' + paramName)\u000a        \u000a        for thisPractice_Afirst in practice_Afirst:\u000a            currentLoop = practice_Afirst\u000a            # abbreviate parameter names if possible (e.g. rgb = thisPractice_Afirst.rgb)\u000a            if thisPractice_Afirst != None:\u000a                for paramName in thisPractice_Afirst.keys():\u000a                    exec(paramName + '= thisPractice_Afirst.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            practice_trials_Afirst = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='practice_trials_Afirst')\u000a            thisExp.addLoop(practice_trials_Afirst)  # add the loop to the experiment\u000a            thisPractice_trials_Afirst = practice_trials_Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisPractice_trials_Afirst.rgb)\u000a            if thisPractice_trials_Afirst != None:\u000a                for paramName in thisPractice_trials_Afirst.keys():\u000a                    exec(paramName + '= thisPractice_trials_Afirst.' + paramName)\u000a            \u000a            for thisPractice_trials_Afirst in practice_trials_Afirst:\u000a                currentLoop = practice_trials_Afirst\u000a                # abbreviate parameter names if possible (e.g. rgb = thisPractice_trials_Afirst.rgb)\u000a                if thisPractice_trials_Afirst != None:\u000a                    for paramName in thisPractice_trials_Afirst.keys():\u000a                        exec(paramName + '= thisPractice_trials_Afirst.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Afirst (TrialHandler)\u000a                practice_trials_Afirst.addData('required_response_A.keys',required_response_A.keys)\u000a                practice_trials_Afirst.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    practice_trials_Afirst.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Afirst (TrialHandler)\u000a                practice_trials_Afirst.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                practice_trials_Afirst.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    practice_trials_Afirst.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'practice_trials_Afirst'\u000a            \u000a            \u000a            #------Prepare to start Routine "practice_postblock_A"-------\u000a            t = 0\u000a            practice_postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Afirst.data['required_response_A.corr'].count()) - float(practice_trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Asecond.data['required_response_A.corr'].count()) - float(practice_trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, prac_block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, prac_block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('prac_block_A_percentage_accuracy', prac_block_A_percentage_accuracy)&#10;##thisExp.addData('prac_block_A_median_latency', prac_block_A_median_latency)\u000a            practice_aim_box_A.setText(aim)\u000a            practice_accuracy_box_A.setText(msg_accuracy)\u000a            practice_latency_box_A.setText(msg_latency)\u000a            press_box_prac_A.setText(press_message)\u000a            practice_postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            practice_postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            practice_postblock_AComponents = []\u000a            practice_postblock_AComponents.append(practice_aim_box_A)\u000a            practice_postblock_AComponents.append(practice_accuracy_box_A)\u000a            practice_postblock_AComponents.append(practice_latency_box_A)\u000a            practice_postblock_AComponents.append(press_box_prac_A)\u000a            practice_postblock_AComponents.append(practice_postblock_response_A)\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "practice_postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = practice_postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *practice_aim_box_A* updates\u000a                if t >= 0.4 and practice_aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_aim_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_aim_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_accuracy_box_A* updates\u000a                if t >= 0.4 and practice_accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_latency_box_A* updates\u000a                if t >= 0.4 and practice_latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_latency_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_prac_A* updates\u000a                if t >= 0.4 and press_box_prac_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_prac_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_prac_A.frameNStart = frameN  # exact frame index\u000a                    press_box_prac_A.setAutoDraw(True)\u000a                \u000a                # *practice_postblock_response_A* updates\u000a                if t >= 1 and practice_postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    practice_postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if practice_postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in practice_postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "practice_postblock_A"-------\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "practice_postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Afirst_nReps repeats of 'practice_Afirst'\u000a        \u000a        \u000a        #------Prepare to start Routine "preblock_B"-------\u000a        t = 0\u000a        preblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)\u000a        rule_box_B.setText(rule_B)\u000a        preblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        preblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        preblock_BComponents = []\u000a        preblock_BComponents.append(rule_box_B)\u000a        preblock_BComponents.append(preblock_response_B)\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "preblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = preblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *rule_box_B* updates\u000a            if t >= 0.4 and rule_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rule_box_B.tStart = t  # underestimates by a little under one frame\u000a                rule_box_B.frameNStart = frameN  # exact frame index\u000a                rule_box_B.setAutoDraw(True)\u000a            \u000a            # *preblock_response_B* updates\u000a            if t >= 1 and preblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                preblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                preblock_response_B.frameNStart = frameN  # exact frame index\u000a                preblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if preblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in preblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "preblock_B"-------\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "preblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        practice_trials_B = data.TrialHandler(nReps=reptitions, method='random', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=data.importConditions('block_layout.xlsx'),\u000a            seed=None, name='practice_trials_B')\u000a        thisExp.addLoop(practice_trials_B)  # add the loop to the experiment\u000a        thisPractice_trials_B = practice_trials_B.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisPractice_trials_B.rgb)\u000a        if thisPractice_trials_B != None:\u000a            for paramName in thisPractice_trials_B.keys():\u000a                exec(paramName + '= thisPractice_trials_B.' + paramName)\u000a        \u000a        for thisPractice_trials_B in practice_trials_B:\u000a            currentLoop = practice_trials_B\u000a            # abbreviate parameter names if possible (e.g. rgb = thisPractice_trials_B.rgb)\u000a            if thisPractice_trials_B != None:\u000a                for paramName in thisPractice_trials_B.keys():\u000a                    exec(paramName + '= thisPractice_trials_B.' + paramName)\u000a            \u000a            #------Prepare to start Routine "trial_B"-------\u000a            t = 0\u000a            trial_BClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'\u000a            image_stimulus1_box_B.setPos(image_stimulus1_location)\u000a            image_stimulus1_box_B.setImage(img_stimulus1)\u000a            image_stimulus2_box_B.setPos(image_stimulus2_location)\u000a            image_stimulus2_box_B.setImage(img_stimulus2)\u000a            stimulus1_box_B.setText(stimulus1)\u000a            stimulus1_box_B.setPos(stimulus1_location)\u000a            stimulus2_box_B.setText(stimulus2)\u000a            stimulus2_box_B.setPos(stimulus2_location)\u000a            required_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            required_response_B.status = NOT_STARTED\u000a            feedback_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            feedback_response_B.status = NOT_STARTED\u000a            left_box_B.setText(response_option_left)\u000a            left_box_B.setPos(response_option_left_location)\u000a            right_box_B.setText(response_option_right)\u000a            right_box_B.setPos(response_option_right_location)\u000a            accuracy_feedback_box_B.setPos(accuracy_feedback_location)\u000a            # keep track of which components have finished\u000a            trial_BComponents = []\u000a            trial_BComponents.append(image_stimulus1_box_B)\u000a            trial_BComponents.append(image_stimulus2_box_B)\u000a            trial_BComponents.append(stimulus1_box_B)\u000a            trial_BComponents.append(stimulus2_box_B)\u000a            trial_BComponents.append(required_response_B)\u000a            trial_BComponents.append(feedback_response_B)\u000a            trial_BComponents.append(left_box_B)\u000a            trial_BComponents.append(right_box_B)\u000a            trial_BComponents.append(accuracy_feedback_box_B)\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "trial_B"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = trial_BClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                # Accuracy feedback message&#10;if len(feedback_response_B.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                \u000a                # *image_stimulus1_box_B* updates\u000a                if t >= 0.4 and image_stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *image_stimulus2_box_B* updates\u000a                if t >= 0.4 and image_stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus1_box_B* updates\u000a                if t >= 0.4 and stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus2_box_B* updates\u000a                if t >= 0.4 and stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *required_response_B* updates\u000a                if t >= 0.4 and required_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    required_response_B.tStart = t  # underestimates by a little under one frame\u000a                    required_response_B.frameNStart = frameN  # exact frame index\u000a                    required_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `required_allowed`\u000a                    if not 'required_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(required_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                        else:  required_allowed = eval(required_allowed)\u000a                    # keyboard checking is just starting\u000a                    required_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if required_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if required_response_B.keys == []:  # then this was the first keypress\u000a                            required_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            required_response_B.rt = required_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (required_response_B.keys == str(required_correct)) or (required_response_B.keys == required_correct):\u000a                                required_response_B.corr = 1\u000a                            else:\u000a                                required_response_B.corr = 0\u000a                            # a response ends the routine\u000a                            continueRoutine = False\u000a                \u000a                # *feedback_response_B* updates\u000a                if t >= 0.4 and feedback_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    feedback_response_B.tStart = t  # underestimates by a little under one frame\u000a                    feedback_response_B.frameNStart = frameN  # exact frame index\u000a                    feedback_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `feedback_allowed`\u000a                    if not 'feedback_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(feedback_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                        else:  feedback_allowed = eval(feedback_allowed)\u000a                    # keyboard checking is just starting\u000a                    feedback_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if feedback_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if feedback_response_B.keys == []:  # then this was the first keypress\u000a                            feedback_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            feedback_response_B.rt = feedback_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (feedback_response_B.keys == str(feedback_correct)) or (feedback_response_B.keys == feedback_correct):\u000a                                feedback_response_B.corr = 1\u000a                            else:\u000a                                feedback_response_B.corr = 0\u000a                \u000a                # *left_box_B* updates\u000a                if t >= response_option_onset and left_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    left_box_B.tStart = t  # underestimates by a little under one frame\u000a                    left_box_B.frameNStart = frameN  # exact frame index\u000a                    left_box_B.setAutoDraw(True)\u000a                \u000a                # *right_box_B* updates\u000a                if t >= response_option_onset and right_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    right_box_B.tStart = t  # underestimates by a little under one frame\u000a                    right_box_B.frameNStart = frameN  # exact frame index\u000a                    right_box_B.setAutoDraw(True)\u000a                \u000a                # *accuracy_feedback_box_B* updates\u000a                if t >= 0.4 and accuracy_feedback_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_feedback_box_B.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_feedback_box_B.frameNStart = frameN  # exact frame index\u000a                    accuracy_feedback_box_B.setAutoDraw(True)\u000a                if accuracy_feedback_box_B.status == STARTED:  # only update if being drawn\u000a                    accuracy_feedback_box_B.setText(accuracyFeedback, log=False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in trial_BComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "trial_B"-------\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a            # check responses\u000a            if required_response_B.keys in ['', [], None]:  # No response was made\u000a               required_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(required_correct).lower() == 'none': required_response_B.corr = 1  # correct non-response\u000a               else: required_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for practice_trials_B (TrialHandler)\u000a            practice_trials_B.addData('required_response_B.keys',required_response_B.keys)\u000a            practice_trials_B.addData('required_response_B.corr', required_response_B.corr)\u000a            if required_response_B.keys != None:  # we had a response\u000a                practice_trials_B.addData('required_response_B.rt', required_response_B.rt)\u000a            # check responses\u000a            if feedback_response_B.keys in ['', [], None]:  # No response was made\u000a               feedback_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(feedback_correct).lower() == 'none': feedback_response_B.corr = 1  # correct non-response\u000a               else: feedback_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for practice_trials_B (TrialHandler)\u000a            practice_trials_B.addData('feedback_response_B.keys',feedback_response_B.keys)\u000a            practice_trials_B.addData('feedback_response_B.corr', feedback_response_B.corr)\u000a            if feedback_response_B.keys != None:  # we had a response\u000a                practice_trials_B.addData('feedback_response_B.rt', feedback_response_B.rt)\u000a            # the Routine "trial_B" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            thisExp.nextEntry()\u000a            \u000a        # completed reptitions repeats of 'practice_trials_B'\u000a        \u000a        \u000a        #------Prepare to start Routine "practice_postblock_B"-------\u000a        t = 0\u000a        practice_postblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;prac_block_B_percentage_accuracy = (float(practice_trials_B.data['required_response_B.corr'].count()) - float(practice_trials_B.data['feedback_response_B.corr'].sum())) /  float(practice_trials_B.data['required_response_B.corr'].count()) * 100 &#10;prac_block_B_median_latency = np.median(practice_trials_B.data['required_response_B.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, prac_block_B_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, prac_block_B_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('prac_block_B_percentage_accuracy', prac_block_B_percentage_accuracy)&#10;##thisExp.addData('prac_block_B_median_latency', prac_block_B_median_latency)\u000a        practice_aim_box_B.setText(aim)\u000a        practice_accuracy_box_B.setText(msg_accuracy)\u000a        practice_latency_box_B.setText(msg_latency)\u000a        press_box_prac_B.setText(press_message)\u000a        practice_postblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        practice_postblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        practice_postblock_BComponents = []\u000a        practice_postblock_BComponents.append(practice_aim_box_B)\u000a        practice_postblock_BComponents.append(practice_accuracy_box_B)\u000a        practice_postblock_BComponents.append(practice_latency_box_B)\u000a        practice_postblock_BComponents.append(press_box_prac_B)\u000a        practice_postblock_BComponents.append(practice_postblock_response_B)\u000a        for thisComponent in practice_postblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "practice_postblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = practice_postblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *practice_aim_box_B* updates\u000a            if t >= 0.4 and practice_aim_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_aim_box_B.tStart = t  # underestimates by a little under one frame\u000a                practice_aim_box_B.frameNStart = frameN  # exact frame index\u000a                practice_aim_box_B.setAutoDraw(True)\u000a            \u000a            # *practice_accuracy_box_B* updates\u000a            if t >= 0.4 and practice_accuracy_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_accuracy_box_B.tStart = t  # underestimates by a little under one frame\u000a                practice_accuracy_box_B.frameNStart = frameN  # exact frame index\u000a                practice_accuracy_box_B.setAutoDraw(True)\u000a            \u000a            # *practice_latency_box_B* updates\u000a            if t >= 0.4 and practice_latency_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_latency_box_B.tStart = t  # underestimates by a little under one frame\u000a                practice_latency_box_B.frameNStart = frameN  # exact frame index\u000a                practice_latency_box_B.setAutoDraw(True)\u000a            \u000a            # *press_box_prac_B* updates\u000a            if t >= 0.4 and press_box_prac_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                press_box_prac_B.tStart = t  # underestimates by a little under one frame\u000a                press_box_prac_B.frameNStart = frameN  # exact frame index\u000a                press_box_prac_B.setAutoDraw(True)\u000a            \u000a            # *practice_postblock_response_B* updates\u000a            if t >= 1 and practice_postblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                practice_postblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                practice_postblock_response_B.frameNStart = frameN  # exact frame index\u000a                practice_postblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if practice_postblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in practice_postblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "practice_postblock_B"-------\u000a        for thisComponent in practice_postblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "practice_postblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        practice_Asecond = data.TrialHandler(nReps=Asecond_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='practice_Asecond')\u000a        thisExp.addLoop(practice_Asecond)  # add the loop to the experiment\u000a        thisPractice_Asecond = practice_Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisPractice_Asecond.rgb)\u000a        if thisPractice_Asecond != None:\u000a            for paramName in thisPractice_Asecond.keys():\u000a                exec(paramName + '= thisPractice_Asecond.' + paramName)\u000a        \u000a        for thisPractice_Asecond in practice_Asecond:\u000a            currentLoop = practice_Asecond\u000a            # abbreviate parameter names if possible (e.g. rgb = thisPractice_Asecond.rgb)\u000a            if thisPractice_Asecond != None:\u000a                for paramName in thisPractice_Asecond.keys():\u000a                    exec(paramName + '= thisPractice_Asecond.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            practice_trials_Asecond = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='practice_trials_Asecond')\u000a            thisExp.addLoop(practice_trials_Asecond)  # add the loop to the experiment\u000a            thisPractice_trials_Asecond = practice_trials_Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisPractice_trials_Asecond.rgb)\u000a            if thisPractice_trials_Asecond != None:\u000a                for paramName in thisPractice_trials_Asecond.keys():\u000a                    exec(paramName + '= thisPractice_trials_Asecond.' + paramName)\u000a            \u000a            for thisPractice_trials_Asecond in practice_trials_Asecond:\u000a                currentLoop = practice_trials_Asecond\u000a                # abbreviate parameter names if possible (e.g. rgb = thisPractice_trials_Asecond.rgb)\u000a                if thisPractice_trials_Asecond != None:\u000a                    for paramName in thisPractice_trials_Asecond.keys():\u000a                        exec(paramName + '= thisPractice_trials_Asecond.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Asecond (TrialHandler)\u000a                practice_trials_Asecond.addData('required_response_A.keys',required_response_A.keys)\u000a                practice_trials_Asecond.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    practice_trials_Asecond.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for practice_trials_Asecond (TrialHandler)\u000a                practice_trials_Asecond.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                practice_trials_Asecond.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    practice_trials_Asecond.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'practice_trials_Asecond'\u000a            \u000a            \u000a            #------Prepare to start Routine "practice_postblock_A"-------\u000a            t = 0\u000a            practice_postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Afirst.data['required_response_A.corr'].count()) - float(practice_trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'):  &#10;    prac_block_A_percentage_accuracy = (float(practice_trials_Asecond.data['required_response_A.corr'].count()) - float(practice_trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(practice_trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    prac_block_A_median_latency = np.median(practice_trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, prac_block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, prac_block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('prac_block_A_percentage_accuracy', prac_block_A_percentage_accuracy)&#10;##thisExp.addData('prac_block_A_median_latency', prac_block_A_median_latency)\u000a            practice_aim_box_A.setText(aim)\u000a            practice_accuracy_box_A.setText(msg_accuracy)\u000a            practice_latency_box_A.setText(msg_latency)\u000a            press_box_prac_A.setText(press_message)\u000a            practice_postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            practice_postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            practice_postblock_AComponents = []\u000a            practice_postblock_AComponents.append(practice_aim_box_A)\u000a            practice_postblock_AComponents.append(practice_accuracy_box_A)\u000a            practice_postblock_AComponents.append(practice_latency_box_A)\u000a            practice_postblock_AComponents.append(press_box_prac_A)\u000a            practice_postblock_AComponents.append(practice_postblock_response_A)\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "practice_postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = practice_postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *practice_aim_box_A* updates\u000a                if t >= 0.4 and practice_aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_aim_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_aim_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_accuracy_box_A* updates\u000a                if t >= 0.4 and practice_accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *practice_latency_box_A* updates\u000a                if t >= 0.4 and practice_latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_latency_box_A.frameNStart = frameN  # exact frame index\u000a                    practice_latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_prac_A* updates\u000a                if t >= 0.4 and press_box_prac_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_prac_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_prac_A.frameNStart = frameN  # exact frame index\u000a                    press_box_prac_A.setAutoDraw(True)\u000a                \u000a                # *practice_postblock_response_A* updates\u000a                if t >= 1 and practice_postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    practice_postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    practice_postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    practice_postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if practice_postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in practice_postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "practice_postblock_A"-------\u000a            for thisComponent in practice_postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "practice_postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Asecond_nReps repeats of 'practice_Asecond'\u000a        \u000a        \u000a        #------Prepare to start Routine "end_practice_blocks"-------\u000a        t = 0\u000a        end_practice_blocksClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Assess if acc and latency mastery criteria were met&#10;if (prac_block_A_percentage_accuracy >= accuracyCriterion) and (prac_block_B_percentage_accuracy >= accuracyCriterion) and (prac_block_A_median_latency <= latencyCriterion) and (prac_block_B_median_latency <= latencyCriterion):&#10;    complete_test_blocks = n_pairs_test_blocks # latter from blocks.xlsx&#10;    practice_blocks.finished = True\u000a        # keep track of which components have finished\u000a        end_practice_blocksComponents = []\u000a        for thisComponent in end_practice_blocksComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "end_practice_blocks"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = end_practice_blocksClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in end_practice_blocksComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "end_practice_blocks"-------\u000a        for thisComponent in end_practice_blocksComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "end_practice_blocks" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a    # completed max_pairs_practice_blocks repeats of 'practice_blocks'\u000a    \u000a    \u000a    # set up handler to look after randomisation of conditions etc\u000a    test_blocks = data.TrialHandler(nReps=complete_test_blocks, method='sequential', \u000a        extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a        trialList=[None],\u000a        seed=None, name='test_blocks')\u000a    thisExp.addLoop(test_blocks)  # add the loop to the experiment\u000a    thisTest_block = test_blocks.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTest_block.rgb)\u000a    if thisTest_block != None:\u000a        for paramName in thisTest_block.keys():\u000a            exec(paramName + '= thisTest_block.' + paramName)\u000a    \u000a    for thisTest_block in test_blocks:\u000a        currentLoop = test_blocks\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTest_block.rgb)\u000a        if thisTest_block != None:\u000a            for paramName in thisTest_block.keys():\u000a                exec(paramName + '= thisTest_block.' + paramName)\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        Afirst = data.TrialHandler(nReps=Afirst_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='Afirst')\u000a        thisExp.addLoop(Afirst)  # add the loop to the experiment\u000a        thisAfirst = Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisAfirst.rgb)\u000a        if thisAfirst != None:\u000a            for paramName in thisAfirst.keys():\u000a                exec(paramName + '= thisAfirst.' + paramName)\u000a        \u000a        for thisAfirst in Afirst:\u000a            currentLoop = Afirst\u000a            # abbreviate parameter names if possible (e.g. rgb = thisAfirst.rgb)\u000a            if thisAfirst != None:\u000a                for paramName in thisAfirst.keys():\u000a                    exec(paramName + '= thisAfirst.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            trials_Afirst = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='trials_Afirst')\u000a            thisExp.addLoop(trials_Afirst)  # add the loop to the experiment\u000a            thisTrials_Afirst = trials_Afirst.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisTrials_Afirst.rgb)\u000a            if thisTrials_Afirst != None:\u000a                for paramName in thisTrials_Afirst.keys():\u000a                    exec(paramName + '= thisTrials_Afirst.' + paramName)\u000a            \u000a            for thisTrials_Afirst in trials_Afirst:\u000a                currentLoop = trials_Afirst\u000a                # abbreviate parameter names if possible (e.g. rgb = thisTrials_Afirst.rgb)\u000a                if thisTrials_Afirst != None:\u000a                    for paramName in thisTrials_Afirst.keys():\u000a                        exec(paramName + '= thisTrials_Afirst.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Afirst (TrialHandler)\u000a                trials_Afirst.addData('required_response_A.keys',required_response_A.keys)\u000a                trials_Afirst.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    trials_Afirst.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Afirst (TrialHandler)\u000a                trials_Afirst.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                trials_Afirst.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    trials_Afirst.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'trials_Afirst'\u000a            \u000a            \u000a            #------Prepare to start Routine "postblock_A"-------\u000a            t = 0\u000a            postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'): &#10;    block_A_percentage_accuracy = (float(trials_Afirst.data['required_response_A.corr'].count()) - float(trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'): &#10;    block_A_percentage_accuracy = (float(trials_Asecond.data['required_response_A.corr'].count()) - float(trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('block_A_percentage_accuracy', block_A_percentage_accuracy)&#10;##thisExp.addData('block_A_median_latency', block_A_median_latency)\u000a            aim_box_A.setText(aim)\u000a            accuracy_box_A.setText(msg_accuracy)\u000a            latency_box_A.setText(msg_latency)\u000a            press_box_A.setText(press_message)\u000a            postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            postblock_AComponents = []\u000a            postblock_AComponents.append(aim_box_A)\u000a            postblock_AComponents.append(accuracy_box_A)\u000a            postblock_AComponents.append(latency_box_A)\u000a            postblock_AComponents.append(press_box_A)\u000a            postblock_AComponents.append(postblock_response_A)\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *aim_box_A* updates\u000a                if t >= 0.4 and aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    aim_box_A.frameNStart = frameN  # exact frame index\u000a                    aim_box_A.setAutoDraw(True)\u000a                \u000a                # *accuracy_box_A* updates\u000a                if t >= 0.4 and accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *latency_box_A* updates\u000a                if t >= 0.4 and latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    latency_box_A.frameNStart = frameN  # exact frame index\u000a                    latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_A* updates\u000a                if t >= 0.4 and press_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_A.frameNStart = frameN  # exact frame index\u000a                    press_box_A.setAutoDraw(True)\u000a                \u000a                # *postblock_response_A* updates\u000a                if t >= 1 and postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "postblock_A"-------\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Afirst_nReps repeats of 'Afirst'\u000a        \u000a        \u000a        #------Prepare to start Routine "preblock_B"-------\u000a        t = 0\u000a        preblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)\u000a        rule_box_B.setText(rule_B)\u000a        preblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        preblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        preblock_BComponents = []\u000a        preblock_BComponents.append(rule_box_B)\u000a        preblock_BComponents.append(preblock_response_B)\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "preblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = preblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *rule_box_B* updates\u000a            if t >= 0.4 and rule_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                rule_box_B.tStart = t  # underestimates by a little under one frame\u000a                rule_box_B.frameNStart = frameN  # exact frame index\u000a                rule_box_B.setAutoDraw(True)\u000a            \u000a            # *preblock_response_B* updates\u000a            if t >= 1 and preblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                preblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                preblock_response_B.frameNStart = frameN  # exact frame index\u000a                preblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if preblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in preblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "preblock_B"-------\u000a        for thisComponent in preblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "preblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        trials_B = data.TrialHandler(nReps=reptitions, method='random', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=data.importConditions('block_layout.xlsx'),\u000a            seed=None, name='trials_B')\u000a        thisExp.addLoop(trials_B)  # add the loop to the experiment\u000a        thisTrials_B = trials_B.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisTrials_B.rgb)\u000a        if thisTrials_B != None:\u000a            for paramName in thisTrials_B.keys():\u000a                exec(paramName + '= thisTrials_B.' + paramName)\u000a        \u000a        for thisTrials_B in trials_B:\u000a            currentLoop = trials_B\u000a            # abbreviate parameter names if possible (e.g. rgb = thisTrials_B.rgb)\u000a            if thisTrials_B != None:\u000a                for paramName in thisTrials_B.keys():\u000a                    exec(paramName + '= thisTrials_B.' + paramName)\u000a            \u000a            #------Prepare to start Routine "trial_B"-------\u000a            t = 0\u000a            trial_BClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'  # PATTERN REVERED FROM BLOCK A&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'\u000a            image_stimulus1_box_B.setPos(image_stimulus1_location)\u000a            image_stimulus1_box_B.setImage(img_stimulus1)\u000a            image_stimulus2_box_B.setPos(image_stimulus2_location)\u000a            image_stimulus2_box_B.setImage(img_stimulus2)\u000a            stimulus1_box_B.setText(stimulus1)\u000a            stimulus1_box_B.setPos(stimulus1_location)\u000a            stimulus2_box_B.setText(stimulus2)\u000a            stimulus2_box_B.setPos(stimulus2_location)\u000a            required_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            required_response_B.status = NOT_STARTED\u000a            feedback_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            feedback_response_B.status = NOT_STARTED\u000a            left_box_B.setText(response_option_left)\u000a            left_box_B.setPos(response_option_left_location)\u000a            right_box_B.setText(response_option_right)\u000a            right_box_B.setPos(response_option_right_location)\u000a            accuracy_feedback_box_B.setPos(accuracy_feedback_location)\u000a            # keep track of which components have finished\u000a            trial_BComponents = []\u000a            trial_BComponents.append(image_stimulus1_box_B)\u000a            trial_BComponents.append(image_stimulus2_box_B)\u000a            trial_BComponents.append(stimulus1_box_B)\u000a            trial_BComponents.append(stimulus2_box_B)\u000a            trial_BComponents.append(required_response_B)\u000a            trial_BComponents.append(feedback_response_B)\u000a            trial_BComponents.append(left_box_B)\u000a            trial_BComponents.append(right_box_B)\u000a            trial_BComponents.append(accuracy_feedback_box_B)\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "trial_B"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = trial_BClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                # Accuracy feedback message&#10;if len(feedback_response_B.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                \u000a                # *image_stimulus1_box_B* updates\u000a                if t >= 0.4 and image_stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *image_stimulus2_box_B* updates\u000a                if t >= 0.4 and image_stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    image_stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    image_stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    image_stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus1_box_B* updates\u000a                if t >= 0.4 and stimulus1_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus1_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus1_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus1_box_B.setAutoDraw(True)\u000a                \u000a                # *stimulus2_box_B* updates\u000a                if t >= 0.4 and stimulus2_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    stimulus2_box_B.tStart = t  # underestimates by a little under one frame\u000a                    stimulus2_box_B.frameNStart = frameN  # exact frame index\u000a                    stimulus2_box_B.setAutoDraw(True)\u000a                \u000a                # *required_response_B* updates\u000a                if t >= 0.4 and required_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    required_response_B.tStart = t  # underestimates by a little under one frame\u000a                    required_response_B.frameNStart = frameN  # exact frame index\u000a                    required_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `required_allowed`\u000a                    if not 'required_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(required_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                        else:  required_allowed = eval(required_allowed)\u000a                    # keyboard checking is just starting\u000a                    required_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if required_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if required_response_B.keys == []:  # then this was the first keypress\u000a                            required_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            required_response_B.rt = required_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (required_response_B.keys == str(required_correct)) or (required_response_B.keys == required_correct):\u000a                                required_response_B.corr = 1\u000a                            else:\u000a                                required_response_B.corr = 0\u000a                            # a response ends the routine\u000a                            continueRoutine = False\u000a                \u000a                # *feedback_response_B* updates\u000a                if t >= 0.4 and feedback_response_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    feedback_response_B.tStart = t  # underestimates by a little under one frame\u000a                    feedback_response_B.frameNStart = frameN  # exact frame index\u000a                    feedback_response_B.status = STARTED\u000a                    # AllowedKeys looks like a variable named `feedback_allowed`\u000a                    if not 'feedback_allowed' in locals():\u000a                        logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                        core.quit()\u000a                    if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                        if not isinstance(feedback_allowed, basestring):\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                            core.quit()\u000a                        elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                        else:  feedback_allowed = eval(feedback_allowed)\u000a                    # keyboard checking is just starting\u000a                    feedback_response_B.clock.reset()  # now t=0\u000a                    event.clearEvents(eventType='keyboard')\u000a                if feedback_response_B.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        if feedback_response_B.keys == []:  # then this was the first keypress\u000a                            feedback_response_B.keys = theseKeys[0]  # just the first key pressed\u000a                            feedback_response_B.rt = feedback_response_B.clock.getTime()\u000a                            # was this 'correct'?\u000a                            if (feedback_response_B.keys == str(feedback_correct)) or (feedback_response_B.keys == feedback_correct):\u000a                                feedback_response_B.corr = 1\u000a                            else:\u000a                                feedback_response_B.corr = 0\u000a                \u000a                # *left_box_B* updates\u000a                if t >= response_option_onset and left_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    left_box_B.tStart = t  # underestimates by a little under one frame\u000a                    left_box_B.frameNStart = frameN  # exact frame index\u000a                    left_box_B.setAutoDraw(True)\u000a                \u000a                # *right_box_B* updates\u000a                if t >= response_option_onset and right_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    right_box_B.tStart = t  # underestimates by a little under one frame\u000a                    right_box_B.frameNStart = frameN  # exact frame index\u000a                    right_box_B.setAutoDraw(True)\u000a                \u000a                # *accuracy_feedback_box_B* updates\u000a                if t >= 0.4 and accuracy_feedback_box_B.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_feedback_box_B.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_feedback_box_B.frameNStart = frameN  # exact frame index\u000a                    accuracy_feedback_box_B.setAutoDraw(True)\u000a                if accuracy_feedback_box_B.status == STARTED:  # only update if being drawn\u000a                    accuracy_feedback_box_B.setText(accuracyFeedback, log=False)\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in trial_BComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "trial_B"-------\u000a            for thisComponent in trial_BComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a            # check responses\u000a            if required_response_B.keys in ['', [], None]:  # No response was made\u000a               required_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(required_correct).lower() == 'none': required_response_B.corr = 1  # correct non-response\u000a               else: required_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for trials_B (TrialHandler)\u000a            trials_B.addData('required_response_B.keys',required_response_B.keys)\u000a            trials_B.addData('required_response_B.corr', required_response_B.corr)\u000a            if required_response_B.keys != None:  # we had a response\u000a                trials_B.addData('required_response_B.rt', required_response_B.rt)\u000a            # check responses\u000a            if feedback_response_B.keys in ['', [], None]:  # No response was made\u000a               feedback_response_B.keys=None\u000a               # was no response the correct answer?!\u000a               if str(feedback_correct).lower() == 'none': feedback_response_B.corr = 1  # correct non-response\u000a               else: feedback_response_B.corr = 0  # failed to respond (incorrectly)\u000a            # store data for trials_B (TrialHandler)\u000a            trials_B.addData('feedback_response_B.keys',feedback_response_B.keys)\u000a            trials_B.addData('feedback_response_B.corr', feedback_response_B.corr)\u000a            if feedback_response_B.keys != None:  # we had a response\u000a                trials_B.addData('feedback_response_B.rt', feedback_response_B.rt)\u000a            # the Routine "trial_B" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            thisExp.nextEntry()\u000a            \u000a        # completed reptitions repeats of 'trials_B'\u000a        \u000a        \u000a        #------Prepare to start Routine "postblock_B"-------\u000a        t = 0\u000a        postblock_BClock.reset()  # clock \u000a        frameN = -1\u000a        # update component parameters for each repeat\u000a        # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;block_B_percentage_accuracy = (float(trials_B.data['required_response_B.corr'].count()) - float(trials_B.data['feedback_response_B.corr'].sum())) /  float(trials_B.data['required_response_B.corr'].count()) * 100 &#10;block_B_median_latency = np.median(trials_B.data['required_response_B.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, block_B_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, block_B_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('block_B_percentage_accuracy', block_B_percentage_accuracy)&#10;##thisExp.addData('block_B_median_latency', block_B_median_latency)\u000a        aim_box_B.setText(aim)\u000a        accuracy_box_B.setText(msg_accuracy)\u000a        latency_box_B.setText(msg_latency)\u000a        press_box_B.setText(press_message)\u000a        postblock_response_B = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        postblock_response_B.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        postblock_BComponents = []\u000a        postblock_BComponents.append(aim_box_B)\u000a        postblock_BComponents.append(accuracy_box_B)\u000a        postblock_BComponents.append(latency_box_B)\u000a        postblock_BComponents.append(press_box_B)\u000a        postblock_BComponents.append(postblock_response_B)\u000a        for thisComponent in postblock_BComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "postblock_B"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = postblock_BClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *aim_box_B* updates\u000a            if t >= 0.4 and aim_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                aim_box_B.tStart = t  # underestimates by a little under one frame\u000a                aim_box_B.frameNStart = frameN  # exact frame index\u000a                aim_box_B.setAutoDraw(True)\u000a            \u000a            # *accuracy_box_B* updates\u000a            if t >= 0.4 and accuracy_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                accuracy_box_B.tStart = t  # underestimates by a little under one frame\u000a                accuracy_box_B.frameNStart = frameN  # exact frame index\u000a                accuracy_box_B.setAutoDraw(True)\u000a            \u000a            # *latency_box_B* updates\u000a            if t >= 0.4 and latency_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                latency_box_B.tStart = t  # underestimates by a little under one frame\u000a                latency_box_B.frameNStart = frameN  # exact frame index\u000a                latency_box_B.setAutoDraw(True)\u000a            \u000a            # *press_box_B* updates\u000a            if t >= 0.4 and press_box_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                press_box_B.tStart = t  # underestimates by a little under one frame\u000a                press_box_B.frameNStart = frameN  # exact frame index\u000a                press_box_B.setAutoDraw(True)\u000a            \u000a            # *postblock_response_B* updates\u000a            if t >= 1 and postblock_response_B.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                postblock_response_B.tStart = t  # underestimates by a little under one frame\u000a                postblock_response_B.frameNStart = frameN  # exact frame index\u000a                postblock_response_B.status = STARTED\u000a                # keyboard checking is just starting\u000a                event.clearEvents(eventType='keyboard')\u000a            if postblock_response_B.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in postblock_BComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                core.quit()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "postblock_B"-------\u000a        for thisComponent in postblock_BComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        # the Routine "postblock_B" was not non-slip safe, so reset the non-slip timer\u000a        routineTimer.reset()\u000a        \u000a        # set up handler to look after randomisation of conditions etc\u000a        Asecond = data.TrialHandler(nReps=Asecond_nReps, method='sequential', \u000a            extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a            trialList=[None],\u000a            seed=None, name='Asecond')\u000a        thisExp.addLoop(Asecond)  # add the loop to the experiment\u000a        thisAsecond = Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a        # abbreviate parameter names if possible (e.g. rgb=thisAsecond.rgb)\u000a        if thisAsecond != None:\u000a            for paramName in thisAsecond.keys():\u000a                exec(paramName + '= thisAsecond.' + paramName)\u000a        \u000a        for thisAsecond in Asecond:\u000a            currentLoop = Asecond\u000a            # abbreviate parameter names if possible (e.g. rgb = thisAsecond.rgb)\u000a            if thisAsecond != None:\u000a                for paramName in thisAsecond.keys():\u000a                    exec(paramName + '= thisAsecond.' + paramName)\u000a            \u000a            #------Prepare to start Routine "preblock_A"-------\u000a            t = 0\u000a            preblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# Generate list of stimuli for the block&#10;stim1_catA_stimuli_many = generate_trials('labelA_stimuli', 2, True)  # function and variable determined at begin exp.&#10;stim1_catB_stimuli_many = generate_trials('labelB_stimuli', 2, True)&#10;stim2_catA_stimuli_many = generate_trials('targetA_stimuli', 2, True)&#10;stim2_catB_stimuli_many = generate_trials('targetB_stimuli', 2, True)&#10;img_stim1_catA_stimuli_many = generate_trials('labelA_image_stimuli', 2, True)&#10;img_stim1_catB_stimuli_many = generate_trials('labelB_image_stimuli', 2, True)&#10;img_stim2_catA_stimuli_many = generate_trials('targetA_image_stimuli', 2, True)&#10;img_stim2_catB_stimuli_many = generate_trials('targetB_image_stimuli', 2, True)&#10;\u000a            rule_box_A.setText(rule_A)\u000a            preblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            preblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            preblock_AComponents = []\u000a            preblock_AComponents.append(rule_box_A)\u000a            preblock_AComponents.append(preblock_response_A)\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "preblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = preblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *rule_box_A* updates\u000a                if t >= 0.4 and rule_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    rule_box_A.tStart = t  # underestimates by a little under one frame\u000a                    rule_box_A.frameNStart = frameN  # exact frame index\u000a                    rule_box_A.setAutoDraw(True)\u000a                \u000a                # *preblock_response_A* updates\u000a                if t >= 1 and preblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    preblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    preblock_response_A.frameNStart = frameN  # exact frame index\u000a                    preblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if preblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in preblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "preblock_A"-------\u000a            for thisComponent in preblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "preblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a            \u000a            # set up handler to look after randomisation of conditions etc\u000a            trials_Asecond = data.TrialHandler(nReps=reptitions, method='random', \u000a                extraInfo=expInfo, originPath=u'C:\u005c\u005cUsers\u005c\u005cjeiso\u005c\u005cDesktop\u005c\u005cOpenSourceIRAP-master\u005c\u005cOpen Source IRAP.psyexp',\u000a                trialList=data.importConditions('block_layout.xlsx'),\u000a                seed=None, name='trials_Asecond')\u000a            thisExp.addLoop(trials_Asecond)  # add the loop to the experiment\u000a            thisTrials_Asecond = trials_Asecond.trialList[0]  # so we can initialise stimuli with some values\u000a            # abbreviate parameter names if possible (e.g. rgb=thisTrials_Asecond.rgb)\u000a            if thisTrials_Asecond != None:\u000a                for paramName in thisTrials_Asecond.keys():\u000a                    exec(paramName + '= thisTrials_Asecond.' + paramName)\u000a            \u000a            for thisTrials_Asecond in trials_Asecond:\u000a                currentLoop = trials_Asecond\u000a                # abbreviate parameter names if possible (e.g. rgb = thisTrials_Asecond.rgb)\u000a                if thisTrials_Asecond != None:\u000a                    for paramName in thisTrials_Asecond.keys():\u000a                        exec(paramName + '= thisTrials_Asecond.' + paramName)\u000a                \u000a                #------Prepare to start Routine "trial_A"-------\u000a                t = 0\u000a                trial_AClock.reset()  # clock \u000a                frameN = -1\u000a                # update component parameters for each repeat\u000a                # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(0.5, 'e'), (0.5, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# For each stimlulus, choose a random exemplar from the appropriate list&#10;# word stimulus 1&#10;if stimulus1_category == 'a':&#10;    stimulus1 = stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    stimulus1 = stim1_catB_stimuli_many.pop()&#10;&#10;# word stimulus 2&#10;if stimulus2_category == 'c':&#10;    stimulus2 = stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    stimulus2 = stim2_catB_stimuli_many.pop()&#10;&#10;# image stimulus 1&#10;if stimulus1_category == 'a':&#10;    img_stimulus1 = img_stim1_catA_stimuli_many.pop()&#10;elif stimulus1_category == 'b':&#10;    img_stimulus1 = img_stim1_catB_stimuli_many.pop()&#10;&#10;# image stimulus 2&#10;if stimulus2_category == 'c':&#10;    img_stimulus2 = img_stim2_catA_stimuli_many.pop()&#10;elif stimulus2_category == 'd':&#10;    img_stimulus2 = img_stim2_catB_stimuli_many.pop()&#10;&#10;# set correct and incorrect responses&#10;if moving_response_options == False:&#10;    response_option_left = response_option_B  # i.e., the focal trial type is the right hand one, for hand dominance&#10;    response_option_right = response_option_A&#10;    response_option_onset = 0  # response options are onscreen constantly&#10;    if (trialType == 1) or (trialType == 4):&#10;        required_allowed = 'i'&#10;        required_correct = 'i'&#10;        feedback_allowed = 'e'&#10;        feedback_correct = 'e'&#10;    elif (trialType == 2) or (trialType == 3):&#10;        required_allowed = 'e'&#10;        required_correct = 'e'&#10;        feedback_allowed = 'i'&#10;        feedback_correct = 'i'&#10;elif moving_response_options == True:&#10;    rand_positions = randint(1, 3)&#10;    response_option_onset = 0.4  # response options appear with stimuli&#10;    if rand_positions == 1:&#10;        response_option_left = response_option_B&#10;        response_option_right = response_option_A&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;    elif rand_positions == 2:&#10;        response_option_left = response_option_A&#10;        response_option_right = response_option_B&#10;        if (trialType == 1) or (trialType == 4):&#10;            required_allowed = 'e'&#10;            required_correct = 'e'&#10;            feedback_allowed = 'i'&#10;            feedback_correct = 'i'&#10;        elif (trialType == 2) or (trialType == 3):&#10;            required_allowed = 'i'&#10;            required_correct = 'i'&#10;            feedback_allowed = 'e'&#10;            feedback_correct = 'e'\u000a                image_stimulus1_box_A.setPos(image_stimulus1_location)\u000a                image_stimulus1_box_A.setImage(img_stimulus1)\u000a                image_stimulus2_box_A.setPos(image_stimulus2_location)\u000a                image_stimulus2_box_A.setImage(img_stimulus2)\u000a                stimulus1_box_A.setText(stimulus1)\u000a                stimulus1_box_A.setPos(stimulus1_location)\u000a                stimulus2_box_A.setText(stimulus2)\u000a                stimulus2_box_A.setPos(stimulus2_location)\u000a                required_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                required_response_A.status = NOT_STARTED\u000a                feedback_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a                feedback_response_A.status = NOT_STARTED\u000a                left_box_A.setText(response_option_left)\u000a                left_box_A.setPos(response_option_left_location)\u000a                right_box_A.setText(response_option_right)\u000a                right_box_A.setPos(response_option_right_location)\u000a                accuracy_feedback_box_A.setPos(accuracy_feedback_location)\u000a                # keep track of which components have finished\u000a                trial_AComponents = []\u000a                trial_AComponents.append(image_stimulus1_box_A)\u000a                trial_AComponents.append(image_stimulus2_box_A)\u000a                trial_AComponents.append(stimulus1_box_A)\u000a                trial_AComponents.append(stimulus2_box_A)\u000a                trial_AComponents.append(required_response_A)\u000a                trial_AComponents.append(feedback_response_A)\u000a                trial_AComponents.append(left_box_A)\u000a                trial_AComponents.append(right_box_A)\u000a                trial_AComponents.append(accuracy_feedback_box_A)\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, 'status'):\u000a                        thisComponent.status = NOT_STARTED\u000a                \u000a                #-------Start Routine "trial_A"-------\u000a                continueRoutine = True\u000a                while continueRoutine:\u000a                    # get current time\u000a                    t = trial_AClock.getTime()\u000a                    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                    # update/draw components on each frame\u000a                    # Accuracy feedback message&#10;if len(feedback_response_A.keys)<1:&#10;    accuracyFeedback=""&#10;else:&#10;    accuracyFeedback="X"\u000a                    \u000a                    # *image_stimulus1_box_A* updates\u000a                    if t >= 0.4 and image_stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *image_stimulus2_box_A* updates\u000a                    if t >= 0.4 and image_stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        image_stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        image_stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        image_stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus1_box_A* updates\u000a                    if t >= 0.4 and stimulus1_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus1_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus1_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus1_box_A.setAutoDraw(True)\u000a                    \u000a                    # *stimulus2_box_A* updates\u000a                    if t >= 0.4 and stimulus2_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        stimulus2_box_A.tStart = t  # underestimates by a little under one frame\u000a                        stimulus2_box_A.frameNStart = frameN  # exact frame index\u000a                        stimulus2_box_A.setAutoDraw(True)\u000a                    \u000a                    # *required_response_A* updates\u000a                    if t >= 0.4 and required_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        required_response_A.tStart = t  # underestimates by a little under one frame\u000a                        required_response_A.frameNStart = frameN  # exact frame index\u000a                        required_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `required_allowed`\u000a                        if not 'required_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `required_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(required_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(required_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `required_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in required_allowed: required_allowed = (required_allowed,)\u000a                            else:  required_allowed = eval(required_allowed)\u000a                        # keyboard checking is just starting\u000a                        required_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if required_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(required_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if required_response_A.keys == []:  # then this was the first keypress\u000a                                required_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                required_response_A.rt = required_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (required_response_A.keys == str(required_correct)) or (required_response_A.keys == required_correct):\u000a                                    required_response_A.corr = 1\u000a                                else:\u000a                                    required_response_A.corr = 0\u000a                                # a response ends the routine\u000a                                continueRoutine = False\u000a                    \u000a                    # *feedback_response_A* updates\u000a                    if t >= 0.4 and feedback_response_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        feedback_response_A.tStart = t  # underestimates by a little under one frame\u000a                        feedback_response_A.frameNStart = frameN  # exact frame index\u000a                        feedback_response_A.status = STARTED\u000a                        # AllowedKeys looks like a variable named `feedback_allowed`\u000a                        if not 'feedback_allowed' in locals():\u000a                            logging.error('AllowedKeys variable `feedback_allowed` is not defined.')\u000a                            core.quit()\u000a                        if not type(feedback_allowed) in [list, tuple, np.ndarray]:\u000a                            if not isinstance(feedback_allowed, basestring):\u000a                                logging.error('AllowedKeys variable `feedback_allowed` is not string- or list-like.')\u000a                                core.quit()\u000a                            elif not ',' in feedback_allowed: feedback_allowed = (feedback_allowed,)\u000a                            else:  feedback_allowed = eval(feedback_allowed)\u000a                        # keyboard checking is just starting\u000a                        feedback_response_A.clock.reset()  # now t=0\u000a                        event.clearEvents(eventType='keyboard')\u000a                    if feedback_response_A.status == STARTED:\u000a                        theseKeys = event.getKeys(keyList=list(feedback_allowed))\u000a                        \u000a                        # check for quit:\u000a                        if "escape" in theseKeys:\u000a                            endExpNow = True\u000a                        if len(theseKeys) > 0:  # at least one key was pressed\u000a                            if feedback_response_A.keys == []:  # then this was the first keypress\u000a                                feedback_response_A.keys = theseKeys[0]  # just the first key pressed\u000a                                feedback_response_A.rt = feedback_response_A.clock.getTime()\u000a                                # was this 'correct'?\u000a                                if (feedback_response_A.keys == str(feedback_correct)) or (feedback_response_A.keys == feedback_correct):\u000a                                    feedback_response_A.corr = 1\u000a                                else:\u000a                                    feedback_response_A.corr = 0\u000a                    \u000a                    # *left_box_A* updates\u000a                    if t >= response_option_onset and left_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        left_box_A.tStart = t  # underestimates by a little under one frame\u000a                        left_box_A.frameNStart = frameN  # exact frame index\u000a                        left_box_A.setAutoDraw(True)\u000a                    \u000a                    # *right_box_A* updates\u000a                    if t >= response_option_onset and right_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        right_box_A.tStart = t  # underestimates by a little under one frame\u000a                        right_box_A.frameNStart = frameN  # exact frame index\u000a                        right_box_A.setAutoDraw(True)\u000a                    \u000a                    # *accuracy_feedback_box_A* updates\u000a                    if t >= 0.4 and accuracy_feedback_box_A.status == NOT_STARTED:\u000a                        # keep track of start time/frame for later\u000a                        accuracy_feedback_box_A.tStart = t  # underestimates by a little under one frame\u000a                        accuracy_feedback_box_A.frameNStart = frameN  # exact frame index\u000a                        accuracy_feedback_box_A.setAutoDraw(True)\u000a                    if accuracy_feedback_box_A.status == STARTED:  # only update if being drawn\u000a                        accuracy_feedback_box_A.setText(accuracyFeedback, log=False)\u000a                    \u000a                    # check if all components have finished\u000a                    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                        break\u000a                    continueRoutine = False  # will revert to True if at least one component still running\u000a                    for thisComponent in trial_AComponents:\u000a                        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                            continueRoutine = True\u000a                            break  # at least one component has not yet finished\u000a                    \u000a                    # check for quit (the Esc key)\u000a                    if endExpNow or event.getKeys(keyList=["escape"]):\u000a                        core.quit()\u000a                    \u000a                    # refresh the screen\u000a                    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                        win.flip()\u000a                \u000a                #-------Ending Routine "trial_A"-------\u000a                for thisComponent in trial_AComponents:\u000a                    if hasattr(thisComponent, "setAutoDraw"):\u000a                        thisComponent.setAutoDraw(False)\u000a                # save exemplars to experiment handler so they're written to the csv file&#10;thisExp.addData('stimulus1', stimulus1)&#10;thisExp.addData('stimulus2', stimulus2)&#10;thisExp.addData('img_stimulus1', img_stimulus1)&#10;thisExp.addData('img_stimulus2', img_stimulus2)&#10;thisExp.addData('response_option_left', response_option_left)&#10;thisExp.addData('response_option_right', response_option_right)\u000a                # check responses\u000a                if required_response_A.keys in ['', [], None]:  # No response was made\u000a                   required_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(required_correct).lower() == 'none': required_response_A.corr = 1  # correct non-response\u000a                   else: required_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Asecond (TrialHandler)\u000a                trials_Asecond.addData('required_response_A.keys',required_response_A.keys)\u000a                trials_Asecond.addData('required_response_A.corr', required_response_A.corr)\u000a                if required_response_A.keys != None:  # we had a response\u000a                    trials_Asecond.addData('required_response_A.rt', required_response_A.rt)\u000a                # check responses\u000a                if feedback_response_A.keys in ['', [], None]:  # No response was made\u000a                   feedback_response_A.keys=None\u000a                   # was no response the correct answer?!\u000a                   if str(feedback_correct).lower() == 'none': feedback_response_A.corr = 1  # correct non-response\u000a                   else: feedback_response_A.corr = 0  # failed to respond (incorrectly)\u000a                # store data for trials_Asecond (TrialHandler)\u000a                trials_Asecond.addData('feedback_response_A.keys',feedback_response_A.keys)\u000a                trials_Asecond.addData('feedback_response_A.corr', feedback_response_A.corr)\u000a                if feedback_response_A.keys != None:  # we had a response\u000a                    trials_Asecond.addData('feedback_response_A.rt', feedback_response_A.rt)\u000a                # the Routine "trial_A" was not non-slip safe, so reset the non-slip timer\u000a                routineTimer.reset()\u000a                thisExp.nextEntry()\u000a                \u000a            # completed reptitions repeats of 'trials_Asecond'\u000a            \u000a            \u000a            #------Prepare to start Routine "postblock_A"-------\u000a            t = 0\u000a            postblock_AClock.reset()  # clock \u000a            frameN = -1\u000a            # update component parameters for each repeat\u000a            # Option to simulates using ResponseEmulator:&#10;if Monkey:&#10;    simulated_responses = [(1.1, 'e'), (1.1, 'i')]  # simulated responses take the form (onsetTime, responseKey). You can simulate more than one.&#10;    responder = ResponseEmulator(simulated_responses)&#10;    responder.start()&#10;&#10;# calculate summary stats&#10;if(starting_block == 'a'): &#10;    block_A_percentage_accuracy = (float(trials_Afirst.data['required_response_A.corr'].count()) - float(trials_Afirst.data['feedback_response_A.corr'].sum())) /  float(trials_Afirst.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Afirst.data['required_response_A.rt'])&#10;&#10;if(starting_block == 'b'): &#10;    block_A_percentage_accuracy = (float(trials_Asecond.data['required_response_A.corr'].count()) - float(trials_Asecond.data['feedback_response_A.corr'].sum())) /  float(trials_Asecond.data['required_response_A.corr'].count()) * 100 &#10;    block_A_median_latency = np.median(trials_Asecond.data['required_response_A.rt'])&#10;&#10;# set messages&#10;msg_accuracy = "%s %i %s" %(accuracy, block_A_percentage_accuracy, percentCorrect) &#10;msg_latency = "%s %.2f %s" %(speed, block_A_median_latency, seconds)&#10;&#10;### save summary stats to experiment handler so they're written to the csv file&#10;##thisExp.addData('block_A_percentage_accuracy', block_A_percentage_accuracy)&#10;##thisExp.addData('block_A_median_latency', block_A_median_latency)\u000a            aim_box_A.setText(aim)\u000a            accuracy_box_A.setText(msg_accuracy)\u000a            latency_box_A.setText(msg_latency)\u000a            press_box_A.setText(press_message)\u000a            postblock_response_A = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a            postblock_response_A.status = NOT_STARTED\u000a            # keep track of which components have finished\u000a            postblock_AComponents = []\u000a            postblock_AComponents.append(aim_box_A)\u000a            postblock_AComponents.append(accuracy_box_A)\u000a            postblock_AComponents.append(latency_box_A)\u000a            postblock_AComponents.append(press_box_A)\u000a            postblock_AComponents.append(postblock_response_A)\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, 'status'):\u000a                    thisComponent.status = NOT_STARTED\u000a            \u000a            #-------Start Routine "postblock_A"-------\u000a            continueRoutine = True\u000a            while continueRoutine:\u000a                # get current time\u000a                t = postblock_AClock.getTime()\u000a                frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a                # update/draw components on each frame\u000a                \u000a                \u000a                # *aim_box_A* updates\u000a                if t >= 0.4 and aim_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    aim_box_A.tStart = t  # underestimates by a little under one frame\u000a                    aim_box_A.frameNStart = frameN  # exact frame index\u000a                    aim_box_A.setAutoDraw(True)\u000a                \u000a                # *accuracy_box_A* updates\u000a                if t >= 0.4 and accuracy_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    accuracy_box_A.tStart = t  # underestimates by a little under one frame\u000a                    accuracy_box_A.frameNStart = frameN  # exact frame index\u000a                    accuracy_box_A.setAutoDraw(True)\u000a                \u000a                # *latency_box_A* updates\u000a                if t >= 0.4 and latency_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    latency_box_A.tStart = t  # underestimates by a little under one frame\u000a                    latency_box_A.frameNStart = frameN  # exact frame index\u000a                    latency_box_A.setAutoDraw(True)\u000a                \u000a                # *press_box_A* updates\u000a                if t >= 0.4 and press_box_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    press_box_A.tStart = t  # underestimates by a little under one frame\u000a                    press_box_A.frameNStart = frameN  # exact frame index\u000a                    press_box_A.setAutoDraw(True)\u000a                \u000a                # *postblock_response_A* updates\u000a                if t >= 1 and postblock_response_A.status == NOT_STARTED:\u000a                    # keep track of start time/frame for later\u000a                    postblock_response_A.tStart = t  # underestimates by a little under one frame\u000a                    postblock_response_A.frameNStart = frameN  # exact frame index\u000a                    postblock_response_A.status = STARTED\u000a                    # keyboard checking is just starting\u000a                    event.clearEvents(eventType='keyboard')\u000a                if postblock_response_A.status == STARTED:\u000a                    theseKeys = event.getKeys(keyList=['e', 'i'])\u000a                    \u000a                    # check for quit:\u000a                    if "escape" in theseKeys:\u000a                        endExpNow = True\u000a                    if len(theseKeys) > 0:  # at least one key was pressed\u000a                        # a response ends the routine\u000a                        continueRoutine = False\u000a                \u000a                # check if all components have finished\u000a                if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                    break\u000a                continueRoutine = False  # will revert to True if at least one component still running\u000a                for thisComponent in postblock_AComponents:\u000a                    if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                        continueRoutine = True\u000a                        break  # at least one component has not yet finished\u000a                \u000a                # check for quit (the Esc key)\u000a                if endExpNow or event.getKeys(keyList=["escape"]):\u000a                    core.quit()\u000a                \u000a                # refresh the screen\u000a                if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                    win.flip()\u000a            \u000a            #-------Ending Routine "postblock_A"-------\u000a            for thisComponent in postblock_AComponents:\u000a                if hasattr(thisComponent, "setAutoDraw"):\u000a                    thisComponent.setAutoDraw(False)\u000a            \u000a            # the Routine "postblock_A" was not non-slip safe, so reset the non-slip timer\u000a            routineTimer.reset()\u000a        # completed Asecond_nReps repeats of 'Asecond'\u000a        \u000a    # completed complete_test_blocks repeats of 'test_blocks'\u000a    \u000a    \u000a    #------Prepare to start Routine "end"-------\u000a    t = 0\u000a    endClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    end_box.setText(end_message)\u000a    end_response = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    end_response.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    endComponents = []\u000a    endComponents.append(end_box)\u000a    endComponents.append(end_response)\u000a    for thisComponent in endComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "end"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = endClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *end_box* updates\u000a        if t >= 0.4 and end_box.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            end_box.tStart = t  # underestimates by a little under one frame\u000a            end_box.frameNStart = frameN  # exact frame index\u000a            end_box.setAutoDraw(True)\u000a        \u000a        # *end_response* updates\u000a        if t >= .4 and end_response.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            end_response.tStart = t  # underestimates by a little under one frame\u000a            end_response.frameNStart = frameN  # exact frame index\u000a            end_response.status = STARTED\u000a            # keyboard checking is just starting\u000a            event.clearEvents(eventType='keyboard')\u000a        if end_response.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['return'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in endComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "end"-------\u000a    for thisComponent in endComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "end" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a# completed 1 repeats of 'task'\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p132
sg38
Nsg87
I278396016
sg11
S'practice_blocks'
p133
sg6
g89
sg90
I0
sg15
I01
sg16
g17
sg91
g1
(g92
g40
(dp134
g94
g95
(g96
g97
g98
S'b'
tRp135
(I1
(I1
I2
tg100
I00
S'\x00\x00\x80?\x00\x00\x00\x00'
S'\x00\x00'
Ntbsg101
g95
(g96
g97
g98
S'b'
tRp136
(I1
(I1
I2
tg100
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01'
NtbstRp137
(dp138
g105
(dp139
g94
I01
sg101
I01
ssg107
g130
sg108
(lp140
g94
ag101
asg110
(lp141
I1
aI2
asbsg112
g113
sg114
g115
(g97
(I0
tS'b'
tRp142
(I1
(I1
I2
tg117
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tbsg118
I00
sg119
I2
sg120
I1
sg121
(lp143
Nasg123
Nsg124
g23
(g117
S'\x00\x00\x00\x00'
tRp144
sg126
I0
sg127
I0
sg128
I2
sg129
I01
sbasS'saveWideText'
p145
I01
sS'thisEntry'
p146
(dp147
sS'version'
p148
S''
sS'_paramNamesSoFar'
p149
(lp150
sS'entries'
p151
(lp152
sS'loops'
p153
(lp154
g34
ag130
asS'savePickle'
p155
I00
sb.